"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.validateLatex = exports.parseLatex = exports.Parser = void 0;
var atom_class_1 = require("./atom-class");
var definitions_utils_1 = require("../latex-commands/definitions-utils");
var error_1 = require("../atoms/error");
var group_1 = require("../atoms/group");
var leftright_1 = require("../atoms/leftright");
var macro_1 = require("../atoms/macro");
var prompt_1 = require("../atoms/prompt");
var placeholder_1 = require("../atoms/placeholder");
var subsup_1 = require("../atoms/subsup");
var text_1 = require("../atoms/text");
var modes_utils_1 = require("./modes-utils");
var tokenizer_1 = require("./tokenizer");
var context_1 = require("./context");
var unicode_1 = require("./unicode");
var types_1 = require("../common/types");
//
// - Literal (character token): a letter, digit or punctuation
// - Token: a space `<space>`, a literal, name, group or mode shift
// - Name (control sequence): a token with an initial `\` followed by
//      one or more letters /[a-zA-Z]+\*?/ or followed by a single
//      non-letter (the name of some commands such as `operatorname*`
//      and `hspace*` names end with a `*`) or the `~` token, e.g.
//      `\frac`, `\alpha`, `\!`
// - Symbol: a name which is not a command, with no arguments,
//      e.g. `\pi`
// - Group: a sequence of tokens that start with `<{>` and end
//      with `<}>`
// - Argument: a single token or group after a name
// - Command:  a name followed by some optional argument, and one
//      or more required arguments
//
// Performance to check first char of string: https://jsben.ch/QLjdZ
// A literal is a token other than a special token. It
// may include a multi-character sequence, for example üßëüèª‚ÄçüöÄ
function isLiteral(token) {
    if (!token)
        return false;
    return !/^(<$$>|<$>|<space>|<{>|<}>|#[0-9\?]|\\.+)$/.test(token);
}
/**
 * Transform a list of tokens into a list of atoms (a mathlist in TeX's parlance)
 *
 */
var Parser = /** @class */ (function () {
    /**
     * @param tokens - An array of tokens generated by the lexer.
     *
     * Note: smartFence and registers are usually defined by the GloablContext.
     * However, in some cases they need to be overridden.
     *
     */
    function Parser(tokens, context, options) {
        var _a, _b, _c, _d;
        // Accumulated errors encountered while parsing
        this.errors = [];
        // The current token to be parsed: index in `this.tokens`
        this.index = 0;
        // Counter to prevent deadlock. If `end()` is called too many
        // times (1,000) in a row for the same token, bail.
        this.endCount = 0;
        options !== null && options !== void 0 ? options : (options = {});
        this.tokens = tokens;
        this.context =
            context instanceof context_1.Context && !(options === null || options === void 0 ? void 0 : options.parseMode) && !options.mathstyle
                ? context
                : new context_1.Context({ from: context, mathstyle: options.mathstyle }, options.style);
        this.args = (_a = options.args) !== null && _a !== void 0 ? _a : undefined;
        this.smartFence = this.context.smartFence;
        this.parsingContext = {
            parent: undefined,
            mathlist: [],
            style: (_b = options.style) !== null && _b !== void 0 ? _b : {},
            parseMode: (_c = options.parseMode) !== null && _c !== void 0 ? _c : 'math',
            mathstyle: (_d = options.mathstyle) !== null && _d !== void 0 ? _d : 'displaystyle',
            tabular: false
        };
    }
    Parser.prototype.beginContext = function (options) {
        var _a, _b, _c;
        var current = this.parsingContext;
        var newContext = {
            parent: current,
            mathlist: [],
            style: __assign({}, current.style),
            parseMode: (_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : current.parseMode,
            mathstyle: (_b = options === null || options === void 0 ? void 0 : options.mathstyle) !== null && _b !== void 0 ? _b : current.mathstyle,
            tabular: (_c = options === null || options === void 0 ? void 0 : options.tabular) !== null && _c !== void 0 ? _c : false
        };
        this.parsingContext = newContext;
    };
    Parser.prototype.endContext = function () {
        this.parsingContext = this.parsingContext.parent;
    };
    Parser.prototype.onError = function (err) {
        this.errors.push(__assign({ before: (0, tokenizer_1.tokensToString)(this.tokens.slice(this.index, this.index + 10)), after: (0, tokenizer_1.tokensToString)(this.tokens.slice(Math.max(0, this.index - 10), this.index)) }, err));
    };
    Object.defineProperty(Parser.prototype, "mathlist", {
        get: function () {
            return this.parsingContext.mathlist;
        },
        set: function (value) {
            this.parsingContext.mathlist = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parser.prototype, "parseMode", {
        get: function () {
            return this.parsingContext.parseMode;
        },
        set: function (value) {
            this.parsingContext.parseMode = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parser.prototype, "tabularMode", {
        get: function () {
            return this.parsingContext.tabular;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Parser.prototype, "style", {
        get: function () {
            // Style is inherited
            var context = this.parsingContext;
            while (context) {
                if (context.style)
                    return __assign({}, context.style);
                context = context.parent;
            }
            return {};
        },
        set: function (value) {
            this.parsingContext.style = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * True if we've reached the end of the token stream
     */
    Parser.prototype.end = function () {
        // To prevent a deadlock, count how many times end() is called without the
        // index advancing. If it happens more than 1,000 times in a row,
        // assume something is broken and pretend the stream is finished.
        this.endCount++;
        return this.index >= this.tokens.length || this.endCount > 1000;
    };
    Parser.prototype.next = function () {
        this.index += 1;
    };
    Parser.prototype.get = function () {
        this.endCount = 0;
        return this.index < this.tokens.length ? this.tokens[this.index++] : '';
    };
    Parser.prototype.peek = function () {
        return this.tokens[this.index];
    };
    // If the next token is a Unicode character such as ¬≤ or ‚ÑÇ,
    // expand it with an equivalent LaTeX command.
    Parser.prototype.expandUnicode = function () {
        var _a;
        if (!this.peek())
            return;
        if (this.parseMode !== 'math')
            return;
        // Check if we have a Unicode character such as `¬≤` or `‚ÑÇ`
        var latex = (0, unicode_1.codePointToLatex)(this.peek());
        if (latex)
            (_a = this.tokens).splice.apply(_a, __spreadArray([this.index, 1], (0, tokenizer_1.tokenize)(latex), false));
    };
    /**
     * @return True if the next token matches the input, and advance
     */
    Parser.prototype.match = function (input) {
        if (this.tokens[this.index] === input) {
            this.index++;
            return true;
        }
        return false;
    };
    /**
     * Return the last atom in the mathlisst that can have a
     * subscript/superscript attached to it.
     * If there isn't one, insert a `SubsupAtom` and return it.
     */
    Parser.prototype.lastSubsupAtom = function () {
        var atom;
        if (this.mathlist.length > 0) {
            atom = this.mathlist[this.mathlist.length - 1];
            // If this is a `subsup` atom, it can have a `subsup` attached to it.
            if (atom.type === 'subsup')
                return atom;
            // An atom can have superscript/subscript attached to it if it accepts
            // limits (`\sum`, `\vec`...)
            if (atom.subsupPlacement !== undefined)
                return atom;
        }
        // Create a new `subsup` atom and return it
        atom = new subsup_1.SubsupAtom({ style: this.style });
        this.mathlist.push(atom);
        return atom;
    };
    /**
     * @return True if the next token matches the specified regular expression pattern.
     */
    Parser.prototype.hasPattern = function (pattern) {
        return pattern.test(this.tokens[this.index]);
    };
    Parser.prototype.hasInfixCommand = function () {
        var _a;
        var index = this.index;
        if (index < this.tokens.length && this.tokens[index].startsWith('\\')) {
            var info = (0, definitions_utils_1.getDefinition)(this.tokens[index], this.parseMode);
            if (!info || info.definitionType === 'symbol')
                return false;
            if (info.ifMode && !info.ifMode.includes(this.parseMode))
                return false;
            return (_a = info.infix) !== null && _a !== void 0 ? _a : false;
        }
        return false;
    };
    Parser.prototype.matchColumnSeparator = function () {
        if (!this.tabularMode)
            return false;
        var peek = this.peek();
        if (peek !== '&')
            return false;
        this.index++;
        return true;
    };
    Parser.prototype.matchRowSeparator = function () {
        if (!this.tabularMode)
            return false;
        var peek = this.peek();
        if (peek !== '\\\\' && peek !== '\\cr' && peek !== '\\tabularnewline')
            return false;
        this.index++;
        return true;
    };
    /**
     * Return the appropriate value for a placeholder, either a default
     * one, or if a value was provided for #? via args, that value.
     */
    Parser.prototype.placeholder = function () {
        var _a;
        var placeHolderArg = (_a = this.args) === null || _a === void 0 ? void 0 : _a.call(this, '?');
        if (!placeHolderArg)
            return [new placeholder_1.PlaceholderAtom({ mode: this.parseMode, style: this.style })];
        // If there is a specific value defined for the placeholder,
        // use it.
        return parseLatex(placeHolderArg, {
            parseMode: this.parseMode,
            mathstyle: 'textstyle'
        });
    };
    Parser.prototype.skipWhitespace = function () {
        while (this.match('<space>')) { }
    };
    Parser.prototype.skipUntilToken = function (input) {
        var token = this.tokens[this.index];
        while (token && token !== input)
            token = this.tokens[++this.index];
        if (token === input)
            this.index++;
    };
    Parser.prototype.skipFiller = function () {
        while (this.match('\\relax') || this.match('<space>')) { }
    };
    /**
     * Keywords are used to specify dimensions, and for various other
     * syntactic constructs.
     *
     * Unlike commands, they are not case sensitive.
     *
     * There are 25 keywords:
     *
     * at by bp cc cm dd depth em ex fil fill filll height in minus
     * mm mu pc plus pt sp spread to true width
     *
     * TeX: 8212
     * @return true if the expected keyword is present
     */
    Parser.prototype.matchKeyword = function (keyword) {
        var savedIndex = this.index;
        var done = this.end();
        var value = '';
        while (!done) {
            var token = this.get();
            if (isLiteral(token)) {
                value += token;
                done = this.end() || value.length >= keyword.length;
            }
            else
                done = true;
        }
        var hasKeyword = keyword.toUpperCase() === value.toUpperCase();
        if (!hasKeyword)
            this.index = savedIndex;
        return hasKeyword;
    };
    /**
     * Return a sequence of characters as a string.
     * i.e. 'abcd' returns 'abcd'.
     * Terminates on the first non-literal token encountered
     * e.g. '<{>', '<}>' etc...
     * Will also terminate on character literal ']'
     */
    Parser.prototype.scanString = function () {
        var result = '';
        while (!this.end()) {
            var token = this.peek();
            if (token === ']')
                return result;
            if (token === '<space>')
                result += ' ';
            else if (token.startsWith('\\')) {
                // TeX will give a "Missing \endcsname inserted" error
                // if it encounters any command when expecting a string.
                // We're a bit more lax.
                this.onError({ code: 'unexpected-command-in-string' });
                result += token.substring(1);
            }
            else if (isLiteral(token))
                result += token;
            else {
                // It's '<{>', '<}>', '<$>' or '<$$>
                return result;
            }
            this.next();
        }
        return result;
    };
    /**
     * Return a sequence of characters as a string.
     * Terminates on a balanced closing bracket
     * This is used by the `\ce` command
     */
    Parser.prototype.scanBalancedString = function () {
        var result = '';
        var done = this.end();
        var level = 1;
        while (!done) {
            var token = this.get();
            if (token === '<space>')
                result += ' ';
            else if (token === '<{>') {
                result += '{';
                level += 1;
            }
            else if (token === '<}>') {
                level -= 1;
                if (level > 0)
                    result += '}';
                else
                    this.index -= 1;
            }
            else if (token === '<$>')
                result += '$';
            else if (token === '<$$>')
                result += '$$';
            else
                result += token;
            done = level === 0 || this.end();
        }
        return result;
    };
    /**
     * Return the literal tokens, as a string, until a matching closing "}"
     * Used when handling macros
     */
    Parser.prototype.scanLiteralGroup = function () {
        var _a;
        if (!this.match('<{>'))
            return '';
        var result = '';
        var level = 1;
        while (level > 0 && !this.end()) {
            var token = this.get();
            if (token === '<}>') {
                level -= 1;
                // Don't include final '}'
                if (level > 0)
                    result += '}';
            }
            else if (token === '<{>') {
                level += 1;
                result += '{';
            }
            else {
                if (/\\[a-zA-Z]+$/.test(result) && /^[a-zA-Z]/.test(token))
                    result += ' ';
                result +=
                    (_a = {
                        '<space>': ' ',
                        '<$$>': '$$',
                        '<$>': '$'
                    }[token]) !== null && _a !== void 0 ? _a : token;
            }
        }
        return result;
    };
    /**
     * Return as a number a group of characters representing a
     * numerical quantity.
     *
     * From TeX:8695 (scan_int):
     * > An integer number can be preceded by any number of spaces and `+' or
     * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
     * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
     * > an internal variable.
     */
    Parser.prototype.scanNumber = function (isInteger) {
        var _a, _b;
        if (isInteger === void 0) { isInteger = true; }
        var negative = false;
        var token = this.peek();
        // TeXBook p.269.
        while (token === '<space>' || token === '+' || token === '-') {
            this.get();
            if (token === '-')
                negative = !negative;
            token = this.peek();
        }
        isInteger = Boolean(isInteger);
        var radix = 10;
        var digits = /\d/;
        if (this.match("'")) {
            // Apostrophe indicates an octal value
            radix = 8;
            digits = /[0-7]/;
            isInteger = true;
        }
        else if (this.match('"')) {
            // Double-quote indicates a hex value
            radix = 16;
            // Hex digits have to be upper-case
            digits = /[\dA-F]/;
            isInteger = true;
        }
        else if (this.match('x')) {
            // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
            // For example: 'x3a'
            radix = 16;
            digits = /[\dA-Fa-f]/;
            isInteger = true;
        }
        else if (this.match('`')) {
            // A backtick indicates an alphabetic constant: a letter, or a single-letter command
            token = this.get();
            if (token) {
                if (token.length === 2 && token.startsWith('\\')) {
                    return {
                        number: (negative ? -1 : 1) * ((_a = token.codePointAt(1)) !== null && _a !== void 0 ? _a : 0),
                        base: 'alpha'
                    };
                }
                return {
                    number: (negative ? -1 : 1) * ((_b = token.codePointAt(0)) !== null && _b !== void 0 ? _b : 0),
                    base: 'alpha'
                };
            }
            return null;
        }
        var value = '';
        while (this.hasPattern(digits))
            value += this.get();
        // Parse the fractional part, if applicable
        // Note: TeX does accept `,` as a decimal separator see TeX: `continental_point_token`
        if (!isInteger && (this.match('.') || this.match(','))) {
            value += '.';
            while (this.hasPattern(digits))
                value += this.get();
        }
        var result = isInteger
            ? Number.parseInt(value, radix)
            : Number.parseFloat(value);
        if (Number.isNaN(result))
            return null;
        return {
            number: negative ? -result : result,
            base: radix === 16 ? 'hexadecimal' : radix === 8 ? 'octal' : 'decimal'
        };
    };
    Parser.prototype.scanRegister = function () {
        var _a;
        var index = this.index;
        var number = this.scanNumber(false);
        this.skipWhitespace();
        if (this.match('\\relax'))
            return number;
        var negative = false;
        if (number === null) {
            while (true) {
                var s = this.peek();
                if (s === '-')
                    negative = !negative;
                else if (s !== '+')
                    break;
                this.next();
                this.skipWhitespace();
            }
        }
        if (this.match('\\global')) {
            this.skipWhitespace();
            var register_1 = this.get();
            if (register_1.startsWith('\\')) {
                if (number) {
                    return {
                        register: register_1,
                        global: true,
                        factor: (negative ? -1 : 1) * number.number
                    };
                }
                if (negative)
                    return { register: register_1, global: true, factor: -1 };
                return { register: register_1, global: true };
            }
            this.index = index;
            return null;
        }
        var register = this.get();
        if (!(register === null || register === void 0 ? void 0 : register.startsWith('\\'))) {
            this.index = index;
            return null;
        }
        register = register.substring(1);
        if (!this.context.registers[register]) {
            this.index = index;
            return null;
        }
        if (!negative || number !== null) {
            return {
                register: register,
                factor: (negative ? -1 : 1) * ((_a = number === null || number === void 0 ? void 0 : number.number) !== null && _a !== void 0 ? _a : 1)
            };
        }
        return { register: register };
    };
    Parser.prototype.scanValue = function () {
        var register = this.scanRegister();
        if (register)
            return register;
        var index = this.index;
        var glue = this.scanGlueOrDimen();
        if (glue && ('unit' in glue || ('glue' in glue && 'unit' in glue.glue)))
            return glue;
        this.index = index;
        var number = this.scanNumber();
        if (number)
            return number;
        if (this.end() || !isLiteral(this.peek()))
            return null;
        var s = this.scanString();
        if (s.length > 0)
            return { string: s };
        return null;
    };
    /**
     * Return a dimension
     *
     * See TeX:8831
     */
    Parser.prototype.scanDimen = function () {
        var value = this.scanNumber(false);
        if (value === null)
            return null;
        var dimension = value.number;
        this.skipWhitespace();
        // The `true` keyword is used with magnification `\mag`
        // which we don't support. See TeXBook p. 270
        // > When ‚Äòtrue‚Äô is present, the factor is multiplied by 1000 and
        // > divided by the \mag parameter.
        this.matchKeyword('true');
        this.skipWhitespace();
        var unit;
        if (this.matchKeyword('pt'))
            unit = 'pt';
        else if (this.matchKeyword('mm'))
            unit = 'mm';
        else if (this.matchKeyword('cm'))
            unit = 'cm';
        else if (this.matchKeyword('ex'))
            unit = 'ex';
        else if (this.matchKeyword('px'))
            unit = 'px';
        else if (this.matchKeyword('em'))
            unit = 'em';
        else if (this.matchKeyword('bp'))
            unit = 'bp';
        else if (this.matchKeyword('dd'))
            unit = 'dd';
        else if (this.matchKeyword('pc'))
            unit = 'pc';
        else if (this.matchKeyword('in'))
            unit = 'in';
        else if (this.matchKeyword('mu'))
            unit = 'mu';
        return unit ? { dimension: dimension, unit: unit } : { dimension: dimension };
    };
    Parser.prototype.scanGlueOrDimen = function () {
        var dimen = this.scanDimen();
        if (dimen === null)
            return null;
        // After a dimension, a whitespace is consumed
        this.skipWhitespace();
        // `\\relax` can be used to indicate an end of value,
        // for example if there is the word "plus" right after, but which
        // should not be interpreted as part of the command
        // (note: we discard that \relax)
        if (this.match('\\relax'))
            return dimen;
        var result = { glue: dimen };
        // 'plus', optionally followed by 'minus'
        // ('minus' cannot come before 'plus')
        // dimen or 'hfill'
        if (this.matchKeyword('plus')) {
            // @todo there could also be a \hFilLlL command here
            var grow = this.scanDimen();
            if (grow)
                result.grow = grow;
            else
                return result;
        }
        this.skipWhitespace();
        if (this.match('\\relax'))
            return result;
        this.skipWhitespace();
        if (this.matchKeyword('minus')) {
            // @todo there could also be a \hFilLlL command here
            var shrink = this.scanDimen();
            if (shrink)
                result.shrink = shrink;
            else
                return result;
        }
        if (!result.grow && !result.shrink)
            return dimen;
        return result;
    };
    Parser.prototype.scanColspec = function () {
        this.skipWhitespace();
        var result = [];
        while (!this.end() && !(this.peek() === '<}>' || this.peek() === ']')) {
            var literal = this.get();
            if (literal === 'c' || literal === 'r' || literal === 'l')
                result.push({ align: literal });
            else if (literal === '|')
                result.push({ separator: 'solid' });
            else if (literal === ':')
                result.push({ separator: 'dashed' });
            else if (literal === '@') {
                if (this.match('<{>')) {
                    this.beginContext({ mode: 'math' });
                    result.push({
                        gap: this.scan(function (token) { return token === '<}>'; })
                    });
                    this.endContext();
                }
                if (!this.match('<}>'))
                    this.onError({ code: 'unbalanced-braces' });
            }
        }
        return result;
    };
    /**
     * Scan a `\(...\)` or `\[...\]` sequence
     * @return group for the sequence or null
     */
    Parser.prototype.scanModeSet = function () {
        var mathstyle = undefined;
        if (this.match('\\('))
            mathstyle = 'textstyle';
        if (!mathstyle && this.match('\\['))
            mathstyle = 'displaystyle';
        if (!mathstyle)
            return null;
        this.beginContext({ mode: 'math', mathstyle: mathstyle });
        var result = this.scan(function (token) { return token === (mathstyle === 'displaystyle' ? '\\]' : '\\)'); });
        if (!this.match(mathstyle === 'displaystyle' ? '\\]' : '\\)'))
            this.onError({ code: 'unbalanced-mode-shift' });
        this.endContext();
        return result;
    };
    /**
     * Scan a `$...$` or `$$...$$` sequence
     */
    Parser.prototype.scanModeShift = function () {
        var final = '';
        if (this.match('<$>'))
            final = '<$>';
        if (!final && this.match('<$$>'))
            final = '<$$>';
        if (!final)
            return null;
        this.beginContext({
            mode: 'math',
            mathstyle: '<$>' ? 'textstyle' : 'displaystyle'
        });
        var result = this.scan(function (token) { return token === final; });
        if (!this.match(final))
            this.onError({ code: 'unbalanced-mode-shift' });
        this.endContext();
        return result;
    };
    /**
     * Scan a \begin{env}...\end{end} sequence
     */
    Parser.prototype.scanEnvironment = function () {
        var _a;
        // An environment starts with a \begin command
        if (!this.match('\\begin'))
            return null;
        // The \begin command is immediately followed by the environment
        // name, as a string argument
        var envName = this.scanArgument('string');
        if (!envName)
            return null;
        var def = (0, definitions_utils_1.getEnvironmentDefinition)(envName);
        if (!def) {
            this.onError({
                code: 'unknown-environment',
                arg: envName
            });
            return null;
        }
        // If the environment has some arguments, parse them
        var args = [];
        if (def.params) {
            for (var _i = 0, _b = def.params; _i < _b.length; _i++) {
                var parameter = _b[_i];
                // Parse an argument
                if (parameter.isOptional) {
                    // If it's not present, parseOptionalArgument returns null,
                    // but push it on the list of arguments anyway.
                    // The null value will be interpreted as unspecified
                    // optional value by the command parse function.
                    args.push(this.scanOptionalArgument(parameter.type));
                }
                else {
                    var arg = this.scanArgument(parameter.type);
                    if (!arg)
                        this.onError({ code: 'missing-argument', arg: envName });
                    args.push(arg);
                }
            }
        }
        this.beginContext({ tabular: def.tabular });
        var array = [];
        var rowGaps = [];
        var row = [];
        var done = false;
        do {
            if (this.end()) {
                this.onError({ code: 'unbalanced-environment', arg: envName });
                done = true;
            }
            if (!done && this.match('\\end')) {
                if (this.scanArgument('string') !== envName) {
                    this.onError({
                        code: 'unbalanced-environment',
                        arg: envName
                    });
                }
                done = true;
            }
            if (!done) {
                if (this.matchColumnSeparator()) {
                    row.push(this.mathlist);
                    this.mathlist = [];
                }
                else if (this.matchRowSeparator()) {
                    row.push(this.mathlist);
                    this.mathlist = [];
                    var gap = null;
                    this.skipWhitespace();
                    if (this.match('[')) {
                        gap = this.scanDimen();
                        this.skipWhitespace();
                        this.match(']');
                    }
                    rowGaps.push(gap !== null && gap !== void 0 ? gap : { dimension: 0 });
                    array.push(row);
                    row = [];
                }
                else {
                    (_a = this.mathlist).push.apply(_a, this.scan(function (token) {
                        return [
                            '<}>',
                            '&',
                            '\\end',
                            '\\cr',
                            '\\\\',
                            '\\tabularnewline',
                        ].includes(token);
                    }));
                }
            }
        } while (!done);
        row.push(this.mathlist);
        if (row.length > 0)
            array.push(row);
        this.endContext();
        return def.createAtom(envName, array, rowGaps, args, this.context.maxMatrixCols);
    };
    /**
     * Parse an expression: a literal, or a command and its arguments
     */
    Parser.prototype.scanExpression = function () {
        var savedList = this.mathlist;
        this.mathlist = [];
        if (this.parseExpression()) {
            var result = this.mathlist;
            this.mathlist = savedList;
            return result;
        }
        this.mathlist = savedList;
        return null;
    };
    /**
     * Parse a sequence until a group end marker, such as
     * `}`, `\end`, `&`, etc...
     *
     * Returns an array of atoms or an empty array if the sequence
     * terminates right away.
     *
     * @param done - A predicate indicating if a token signals the end of a
     * group
     */
    Parser.prototype.scan = function (done) {
        this.beginContext();
        // Default group end marker
        if (!done)
            done = function (token) { return token === '<}>'; };
        // To handle infix commands, we'll keep track of their prefix
        // (tokens coming before them) and their arguments
        var infix = '';
        var infixInfo = null;
        var infixArgs = [];
        var prefix = null;
        while (!this.end() && !done(this.peek())) {
            if (this.hasInfixCommand() && !infix) {
                // The next token is an infix and we have not seen one yet
                // (there can be only one infix command per implicit group).
                infix = this.get();
                // The current parseMode, this.parseMode, may no longer have the value
                // it had when we encountered the infix. However, since all infix are
                // only defined in 'math' mode, we can use the 'math' constant
                // for the parseMode
                infixInfo = (0, definitions_utils_1.getDefinition)(infix, 'math');
                if (infixInfo)
                    infixArgs = this.scanArguments(infixInfo)[1];
                // Save the math list so far and start a new one
                prefix = this.mathlist;
                this.mathlist = [];
            }
            else
                this.parseExpression();
        }
        var result;
        if (infix) {
            console.assert(Boolean(infixInfo));
            infixArgs.unshift(this.mathlist); // Suffix
            if (prefix)
                infixArgs.unshift(prefix);
            result = [
                infixInfo.createAtom({
                    command: infix,
                    args: infixArgs,
                    style: this.style,
                    mode: this.parseMode
                }),
            ];
        }
        else
            result = this.mathlist;
        this.endContext();
        return result;
    };
    /**
     * Parse a group enclosed in a pair of braces: `{...}`.
     *
     * Return either a group Atom or null if not a group.
     *
     * Return a group Atom with an empty body if an empty
     * group (i.e. `{}`).
     *
     * If the group only contains a placeholder, return a placeholder,
     */
    Parser.prototype.scanGroup = function () {
        var initialIndex = this.index;
        if (!this.match('<{>'))
            return null;
        var body = this.scan(function (token) { return token === '<}>'; });
        if (!this.match('<}>'))
            this.onError({ code: 'unbalanced-braces' });
        if (body.length === 1 && body[0].type === 'placeholder')
            return body[0];
        var result = new group_1.GroupAtom(body, this.parseMode);
        result.verbatimLatex = (0, tokenizer_1.tokensToString)(this.tokens.slice(initialIndex, this.index));
        return result;
    };
    Parser.prototype.scanSmartFence = function () {
        this.skipWhitespace();
        if (!this.match('('))
            return null;
        // We've found an open paren... Convert to a `\left...\right`
        this.beginContext();
        var nestLevel = 1;
        while (!this.end() && nestLevel !== 0) {
            if (this.match('('))
                nestLevel += 1;
            if (this.match(')'))
                nestLevel -= 1;
            if (nestLevel !== 0)
                this.parseExpression();
        }
        var result = new leftright_1.LeftRightAtom('', this.mathlist, {
            leftDelim: '(',
            rightDelim: nestLevel === 0 ? ')' : '?'
        });
        this.endContext();
        return result;
    };
    /**
     * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
     *
     * @return The delimiter (as a character or command) or null
     */
    Parser.prototype.scanDelim = function () {
        this.skipWhitespace();
        var token = this.peek();
        if (!token) {
            this.onError({ code: 'unexpected-end-of-string' });
            return null;
        }
        if (!isLiteral(token) && !token.startsWith('\\'))
            return null;
        this.next();
        var info = (0, definitions_utils_1.getDefinition)(token, 'math');
        if (!info) {
            this.onError({ code: 'unknown-command', arg: token });
            return null;
        }
        if (info.definitionType === 'function' &&
            info.ifMode &&
            !info.ifMode.includes(this.parseMode)) {
            this.onError({ code: 'unexpected-delimiter', arg: token });
            return null;
        }
        if (info.definitionType === 'symbol' &&
            (info.type === 'mopen' || info.type === 'mclose'))
            return token;
        // Some symbols are not of type mopen/mclose, but are still
        // valid delimiters...
        // '?' is a special delimiter used as a 'placeholder'
        // (when the closing delimiter is displayed greyed out)
        if (/^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(token))
            return token;
        this.onError({ code: 'unexpected-delimiter', arg: token });
        return null;
    };
    /**
     * Parse a `/left.../right` sequence.
     *
     * Note: the `/middle` command can occur multiple times inside a
     * `/left.../right` sequence, and is handled separately.
     *
     * Return either an atom of type `"leftright"` or null
     */
    Parser.prototype.scanLeftRight = function () {
        var _a;
        if (this.match('\\right')) {
            this.onError({ code: 'unbalanced-braces' });
            return new error_1.ErrorAtom('\\right');
        }
        if (this.match('\\mright')) {
            this.onError({ code: 'unbalanced-braces' });
            return new error_1.ErrorAtom('\\mright');
        }
        var close = '\\right';
        if (!this.match('\\left')) {
            if (!this.match('\\mleft'))
                return null;
            close = '\\mright';
        }
        var leftDelim = this.scanDelim();
        if (!leftDelim) {
            this.onError({ code: 'unexpected-delimiter' });
            return new error_1.ErrorAtom(close === '\\right' ? '\\left' : '\\mleft');
        }
        this.beginContext();
        while (!this.end() && !this.match(close))
            this.parseExpression();
        var body = this.mathlist;
        this.endContext();
        // If we've reached the end and there was no `\right` or
        // there isn't a valid delimiter after `\right`, we'll
        // consider the `\right` missing and set the `rightDelim` to undefined
        var rightDelim = (_a = this.scanDelim()) !== null && _a !== void 0 ? _a : '.';
        return new leftright_1.LeftRightAtom(close === '\\right' ? 'left...right' : 'mleft...mright', body, {
            leftDelim: leftDelim,
            rightDelim: rightDelim,
            style: this.style
        });
    };
    /**
     * Parse a subscript/superscript: `^` and `_`.
     *
     * Modify the last atom accordingly, or create a new 'subsup' carrier.
     *
     */
    Parser.prototype.parseSupSub = function () {
        // No sup/sub in text or command mode.
        if (this.parseMode !== 'math')
            return false;
        // Apply the subscript/superscript to the last rendered atom.
        // If none is present (beginning of the list, i.e. `{^2}`,
        // an empty atom will be created, equivalent to `{{}^2}`
        var token = this.peek();
        if (token !== '^' && token !== '_' && token !== "'")
            return false;
        var target = this.lastSubsupAtom();
        while (token === '^' || token === '_' || token === "'") {
            if (this.match("'")) {
                if (this.match("'")) {
                    // A single quote, twice, is equivalent to '^{\doubleprime}'
                    target.addChild(new atom_class_1.Atom({
                        type: 'mord',
                        command: '\\doubleprime',
                        mode: 'math',
                        value: '\u2032\u2032'
                    }), 'superscript');
                }
                else {
                    // A single quote (prime) is equivalent to '^{\prime}'
                    target.addChild(new atom_class_1.Atom({
                        type: 'mord',
                        command: '\\prime',
                        mode: 'math',
                        value: '\u2032'
                    }), 'superscript');
                }
            }
            else if (this.match('^') || this.match('_')) {
                target.addChildren((0, definitions_utils_1.argAtoms)(this.scanArgument('expression')), token === '_' ? 'subscript' : 'superscript');
            }
            token = this.peek();
        }
        return true;
    };
    /**
     * Parse a `\limits` or `\nolimits` command.
     *
     * This will change the placement of limits to be either above or below
     * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
     *
     * This overrides the calculation made for the placement, which is usually
     * dependent on the displaystyle (`textstyle` prefers `\nolimits`, while
     * `displaystyle` prefers `\limits`).
     */
    Parser.prototype.parseLimits = function () {
        // No limits in text or LaTeX mode.
        if (this.parseMode !== 'math')
            return false;
        // Note: `\limits`, `\nolimits` and `\displaylimits` are only applicable \
        // after an operator.
        // We skip them and ignore them if they are after something other
        // than an operator (TeX throws an error)
        var isLimits = this.match('\\limits');
        var isNoLimits = !isLimits && this.match('\\nolimits');
        var isDisplayLimits = !isNoLimits && !isLimits && this.match('\\displaylimits');
        if (!isLimits && !isNoLimits && !isDisplayLimits)
            return false;
        var opAtom = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
        if (opAtom === null)
            return false;
        // Record that the limits was set through an explicit command
        // so we can generate the appropriate LaTeX later
        opAtom.explicitSubsupPlacement = true;
        if (isLimits)
            opAtom.subsupPlacement = 'over-under';
        if (isNoLimits)
            opAtom.subsupPlacement = 'adjacent';
        if (isDisplayLimits)
            opAtom.subsupPlacement = 'auto';
        return true;
    };
    Parser.prototype.scanArguments = function (info) {
        if (!(info === null || info === void 0 ? void 0 : info.params))
            return [undefined, []];
        var deferredArg = undefined;
        var args = [];
        var i = info.infix ? 2 : 0;
        while (i < info.params.length) {
            var parameter = info.params[i];
            // Parse an argument
            if (parameter.type === 'rest') {
                args.push(this.scan(function (token) {
                    return [
                        '<}>',
                        '&',
                        '\\end',
                        '\\cr',
                        '\\\\',
                        '\\tabularnewline',
                        '\\right',
                    ].includes(token);
                }));
            }
            else if (parameter.isOptional)
                args.push(this.scanOptionalArgument(parameter.type));
            else if (parameter.type.endsWith('*')) {
                // Indicate that a 'yet-to-be-parsed' argument is present
                // which should be accounted for *after* the command has been processed.
                deferredArg = parameter.type.slice(0, -1);
            }
            else
                args.push(this.scanArgument(parameter.type));
            i += 1;
        }
        return [deferredArg, args];
    };
    /**
     * This function is similar to `scanSymbolOrCommand` but is is invoked
     * from a context where commands with arguments are not allowed, specifically
     * when parsing an unbraced argument, i.e. `\frac1\alpha`.
     *
     */
    Parser.prototype.scanSymbolOrLiteral = function () {
        var token = this.peek();
        if (!token)
            return null;
        this.next();
        var result;
        //
        // Is it a literal?
        //
        if (isLiteral(token)) {
            var result_1 = modes_utils_1.Mode.createAtom(this.parseMode, token, __assign({}, this.style));
            return result_1 ? [result_1] : null;
        }
        //
        // Is this a macro?
        //
        result = this.scanMacro(token);
        if (result)
            return [result];
        //
        // Is this a command?
        //
        if (token.startsWith('\\')) {
            var def = (0, definitions_utils_1.getDefinition)(token, this.parseMode);
            if (!def) {
                this.onError({ code: 'unknown-command', arg: token });
                return [new error_1.ErrorAtom(token)];
            }
            if (def.definitionType === 'symbol') {
                //
                // The command is a simple symbol (no arguments)
                //
                var style = __assign({}, this.style);
                if (def.variant)
                    style.variant = def.variant;
                result = new atom_class_1.Atom({
                    type: def.type,
                    command: token,
                    style: style,
                    value: String.fromCodePoint(def.codepoint),
                    mode: this.parseMode,
                    verbatimLatex: token
                });
            }
            else if (def.applyMode || def.applyStyle || def.infix) {
                // The command modifies the mode or style: can't use here
                this.onError({ code: 'invalid-command', arg: token });
                return [new error_1.ErrorAtom(token)];
            }
            else if (def.createAtom) {
                result = def.createAtom({
                    command: token,
                    args: [],
                    style: this.style,
                    mode: this.parseMode
                });
            }
        }
        return result ? [result] : null;
    };
    Parser.prototype.scanArgument = function (type) {
        var _a, _b, _c;
        var _d;
        this.skipFiller();
        var mode = this.parseMode;
        if (type === 'auto')
            type = mode;
        //
        // Argument without braces
        //
        if (!this.match('<{>')) {
            if (type === 'string')
                return this.scanString();
            if (type === 'value')
                return this.scanValue();
            if (type === 'delim')
                return (_d = this.scanDelim()) !== null && _d !== void 0 ? _d : '.';
            if (type === 'expression')
                return this.scanExpression();
            if (type === 'math') {
                if (type !== mode)
                    this.beginContext({ mode: 'math' });
                var result_2 = this.scanSymbolOrLiteral();
                if (type !== mode)
                    this.endContext();
                return result_2;
            }
            if (type === 'text') {
                if (type !== mode)
                    this.beginContext({ mode: 'text' });
                var result_3 = this.scanSymbolOrLiteral();
                if (type !== mode)
                    this.endContext();
                return result_3;
            }
            if (type === 'balanced-string')
                return null;
            if (type === 'rest') {
                return this.scan(function (token) {
                    return [
                        '<}>',
                        '&',
                        '\\end',
                        '\\cr',
                        '\\\\',
                        '\\tabularnewline',
                        '\\right',
                    ].includes(token);
                });
            }
            console.assert(false);
            return null;
        }
        //
        // Braced argument
        //
        if (type === 'text') {
            this.beginContext({ mode: 'text' });
            do
                (_a = this.mathlist).push.apply(_a, this.scan());
            while (!this.match('<}>') && !this.end());
            var atoms = this.mathlist;
            this.endContext();
            // this.index -= 1;
            // const s = this.scanLiteralGroup();
            // const atoms = parseLatex(s, {
            //   context: this.context,
            //   parseMode: 'text',
            //   style: this.parsingContext.style,
            // });
            // this.endContext();
            return { group: atoms };
        }
        if (type === 'math') {
            this.beginContext({ mode: 'math' });
            do
                (_b = this.mathlist).push.apply(_b, this.scan());
            while (!this.match('<}>') && !this.end());
            var atoms = this.mathlist;
            this.endContext();
            return { group: atoms };
        }
        var result = null;
        if (type === 'expression') {
            this.beginContext({ mode: 'math' });
            do
                (_c = this.mathlist).push.apply(_c, this.scan());
            while (!this.match('<}>') && !this.end());
            var atoms = this.mathlist;
            this.endContext();
            return { group: atoms };
        }
        if (type === 'string')
            result = this.scanString();
        else if (type === 'balanced-string')
            result = this.scanBalancedString();
        else if (type === 'colspec')
            result = this.scanColspec();
        else if (type === 'value')
            result = this.scanValue();
        this.skipUntilToken('<}>');
        return result;
    };
    Parser.prototype.scanOptionalArgument = function (argType) {
        argType = argType === 'auto' ? this.parseMode : argType;
        this.skipFiller();
        if (!this.match('['))
            return null;
        var result = null;
        while (!this.end() && !this.match(']')) {
            if (argType === 'string')
                result = this.scanString();
            else if (argType === 'value')
                result = this.scanValue();
            else if (argType === 'colspec')
                result = this.scanColspec();
            else if (argType === 'bbox') {
                // The \bbox command takes a very particular argument:
                // a comma delimited list of up to three arguments:
                // a color, a dimension and a string.
                // Split the string by comma delimited sub-strings, ignoring commas
                // that may be inside (). For example"x, rgb(a, b, c)" would return
                // ['x', 'rgb(a, b, c)']
                var bboxParameter = {};
                var list = this.scanString()
                    .toLowerCase()
                    .trim()
                    .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
                for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                    var element = list_1[_i];
                    var m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
                    if (m) {
                        bboxParameter.padding = {
                            dimension: parseInt(m[1]),
                            unit: m[2]
                        };
                    }
                    else {
                        var m_1 = element.match(/^\s*border\s*:\s*(.*)/);
                        if (m_1)
                            bboxParameter.border = m_1[1];
                        else
                            bboxParameter.backgroundcolor = { string: element };
                    }
                }
                result = bboxParameter;
            }
            else if (argType === 'math') {
                this.beginContext({ mode: 'math' });
                result = this.mathlist.concat(this.scan(function (token) { return token === ']'; }));
                this.endContext();
            }
        }
        return result;
    };
    /** Parse a symbol or a command and its arguments
     * See also `scanSymbolOrLiteral` which is invoked from a context where
     * commands with arguments are not allowed, specifically when parsing an
     * unbraced argument, i.e. `\frac1\alpha`.
     */
    Parser.prototype.scanSymbolOrCommand = function (command) {
        var _a;
        var _this = this;
        var _b, _c, _d;
        if (command === '\\placeholder') {
            var id = this.scanOptionalArgument('string');
            // default value is legacy, ignored if there is a body
            // We need to check if second argument is `correct`, `incorrect` or to be interpreted as math
            var defaultValue = this.scanOptionalArgument('math');
            var defaultAsString = atom_class_1.Atom.serialize(defaultValue, {
                defaultMode: 'math'
            });
            var defaultAtoms = [];
            var correctness = void 0;
            if (!correctness && defaultAsString === 'correct')
                correctness = 'correct';
            else if (!correctness && defaultAsString === 'incorrect')
                correctness = 'incorrect';
            else if (defaultAsString !== '')
                defaultAtoms = defaultValue;
            // const locked =  === 'locked';
            var locked = this.scanOptionalArgument('string') === 'locked';
            var value = this.scanArgument('auto');
            var body = void 0;
            if (value && Array.isArray(value) && value.length > 0)
                body = value;
            else if (value && typeof value === 'object' && 'group' in value)
                body = value.group;
            else
                body = defaultAtoms;
            if (id) {
                return [
                    new prompt_1.PromptAtom(id, correctness, locked, body !== null && body !== void 0 ? body : defaultAtoms, {
                        mode: this.parseMode,
                        style: this.style
                    }),
                ];
            }
            return [new placeholder_1.PlaceholderAtom({ mode: this.parseMode, style: this.style })];
        }
        if (command === '\\renewcommand' ||
            command === '\\newcommand' ||
            command === '\\providecommand' ||
            command === '\\def') {
            // \\renewcommand: error if command is not already defined
            // \\newcommand: error if command is already defined
            // \\providecommand: define command only if it is not already defined
            // \\def: define command, silently overwriting any existing definition
            var index = this.index;
            // Get the command name
            var cmd = this.scanLiteralGroup() || this.next();
            if (!cmd)
                return null;
            // Define (or redefine) a command (or register)
            if (this.context.registers[cmd.substring(1)]) {
                var value = this.scanArgument('string');
                if (value !== null)
                    this.context.registers[cmd.substring(1)] = value;
                var verbatimLatex = (0, tokenizer_1.joinLatex)([
                    command,
                    (0, tokenizer_1.tokensToString)(this.tokens.slice(index, this.index)),
                ]);
                return [new atom_class_1.Atom({ type: 'text', value: '', verbatimLatex: verbatimLatex })];
            }
            // Could be a macro definition... @todo
            // \newcommand{\cmd}[nargs][optargdefault]{defn}
        }
        // Is this a macro?
        var result = this.scanMacro(command);
        if (result)
            return [result];
        // This wasn't a macro, so let's see if it's a regular command
        var info = (0, definitions_utils_1.getDefinition)(command, this.parseMode);
        // An unknown command, or a command not available in this mode
        if (!info) {
            if (this.parseMode === 'text') {
                if (/[a-zA-Z]/.test((_b = this.peek()) !== null && _b !== void 0 ? _b : '')) {
                    // The following character is a letter: insert a space
                    // i.e. `\alpha x` -> `\alpha~x`
                    // (the spaces are removed by the tokenizer)
                    command += ' ';
                }
                return __spreadArray([], command, true).map(function (c) {
                    return new atom_class_1.Atom({
                        type: 'text',
                        value: c,
                        mode: 'text',
                        style: _this.style
                    });
                });
            }
            this.onError({ code: 'unknown-command', arg: command });
            return [new error_1.ErrorAtom(command)];
        }
        var initialIndex = this.index;
        if (info.definitionType === 'symbol') {
            var style = __assign({}, this.style);
            // Override the variant if an explicit variant is provided
            if (info.variant)
                style.variant = info.variant;
            result = new atom_class_1.Atom({
                type: info.type,
                command: command,
                style: style,
                value: String.fromCodePoint(info.codepoint),
                mode: this.parseMode
            });
        }
        else {
            if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
                // Command not applicable in this mode: ignore it (TeX behavior)
                return [];
            }
            // Parse the arguments.
            //
            // If `deferredArg` is not empty, the content after the command
            // will be parsed *after* the command has been initially processed
            // (atom creation or style application) and passed to
            //
            // This is used for commands such as \textcolor{color}{content}
            // that need to apply the color to the content *after* the
            // style has been changed.
            //
            // In definitions, this is indicated with a parameter type
            // thats ends with a '*' ('math*', 'auto*').
            var savedMode = this.parseMode;
            if (info.applyMode)
                this.parseMode = info.applyMode;
            var deferredArg = undefined;
            var args = [];
            if (info.parse)
                args = info.parse(this);
            else
                _a = this.scanArguments(info), deferredArg = _a[0], args = _a[1];
            this.parseMode = savedMode;
            if (info.applyMode && !info.applyStyle && !info.createAtom)
                return (0, definitions_utils_1.argAtoms)(args[0]);
            if (info.infix) {
                // Infix commands should be handled in scanImplicitGroup
                // If we find an infix command here, it's a syntax error
                // (second infix command in a group) and should be ignored.
                this.onError({
                    code: 'too-many-infix-commands',
                    arg: command
                });
                return null;
            }
            //  Invoke the createAtom() function if present
            if (typeof info.createAtom === 'function') {
                result = info.createAtom({
                    command: command,
                    args: args,
                    style: this.style,
                    mode: this.parseMode
                });
                if (deferredArg)
                    result.body = (0, definitions_utils_1.argAtoms)(this.scanArgument(deferredArg));
            }
            else if (typeof info.applyStyle === 'function') {
                var style = info.applyStyle(this.style, command, args, this.context);
                // No type provided -> the parse function will modify
                // the current style rather than create a new Atom.
                var savedMode_1 = this.parseMode;
                // Change to 'text' (or 'math') mode if necessary
                if (info.applyMode)
                    this.parseMode = info.applyMode;
                // If a deferred arg is expected, process it now
                if (deferredArg) {
                    // Create a temporary style
                    var saveStyle = this.style;
                    this.style = style;
                    var atoms = this.scanArgument(deferredArg);
                    this.style = saveStyle;
                    this.parseMode = savedMode_1;
                    return (0, definitions_utils_1.argAtoms)(atoms);
                }
                // Merge the new style info with the current style
                this.style = style;
            }
            else {
                result = new atom_class_1.Atom({
                    type: 'mord',
                    command: (_c = info.command) !== null && _c !== void 0 ? _c : command,
                    style: __assign({}, this.style),
                    value: command,
                    mode: (_d = info.applyMode) !== null && _d !== void 0 ? _d : this.parseMode
                });
            }
        }
        if (!result)
            return null;
        if (result instanceof atom_class_1.Atom &&
            result.verbatimLatex === undefined &&
            !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)) {
            // We have to use `joinLatex` to correctly handle the case of
            // modal commands, e.g. `{\em m}`
            var verbatim = (0, tokenizer_1.joinLatex)([
                command,
                (0, tokenizer_1.tokensToString)(this.tokens.slice(initialIndex, this.index)),
            ]);
            if (verbatim)
                result.verbatimLatex = verbatim;
        }
        if (result.verbatimLatex === null)
            result.verbatimLatex = undefined;
        if (result.isFunction && this.smartFence) {
            // The command was a function that may be followed by
            // an argument, like `\sin(`
            var smartFence = this.scanSmartFence();
            if (smartFence)
                return [result, smartFence];
        }
        return [result];
    };
    Parser.prototype.scanSymbolCommandOrLiteral = function () {
        this.expandUnicode();
        var token = this.get();
        if (!token)
            return null;
        if (isLiteral(token)) {
            var result = modes_utils_1.Mode.createAtom(this.parseMode, token, __assign({}, this.style));
            if (!result)
                return null;
            if (result.isFunction && this.smartFence) {
                // The atom was a function that may be followed by
                // an argument, like `f(`.
                var smartFence = this.scanSmartFence();
                if (smartFence)
                    return [result, smartFence];
            }
            return [result];
        }
        if (token.startsWith('\\'))
            return this.scanSymbolOrCommand(token);
        if (token === '<space>') {
            if (this.parseMode === 'text')
                return [new text_1.TextAtom(' ', ' ', this.style)];
            return null;
        }
        if (token === '<}>')
            this.onError({ latex: '', code: 'unbalanced-braces' });
        else {
            this.onError({
                latex: '',
                code: 'unexpected-token',
                arg: token
            });
        }
        return null;
    };
    /**
     * Scan the macro name and its arguments and return a macro atom
     */
    Parser.prototype.scanMacro = function (macro) {
        var _a;
        var def = this.context.getMacro(macro);
        if (!def)
            return null;
        var initialIndex = this.index;
        var argCount = def.args;
        // Carry forward the placeholder argument, if any.
        var args = { '?': (_a = this.args) === null || _a === void 0 ? void 0 : _a.call(this, '?') };
        // Parse each argument group as a string. We don't know yet
        // what the proper parse mode is, so defer parsing till later
        // when invoking `parseLatex`
        for (var i = 1; i <= argCount; i++) {
            var arg = this.scanLiteralGroup();
            if (!arg) {
                // If the argument wasn't a group ({}), it may have
                // been a single token or expression, e.g. \frac12
                var index = this.index;
                this.scanExpression();
                arg = (0, tokenizer_1.tokensToString)(this.tokens.slice(index, this.index));
            }
            args[i] = arg;
        }
        // Group the result of the macro expansion
        return new macro_1.MacroAtom(macro, {
            expand: def.expand,
            captureSelection: def.captureSelection,
            args: initialIndex === this.index
                ? null
                : (0, tokenizer_1.tokensToString)(this.tokens.slice(initialIndex, this.index)),
            style: this.parsingContext.style,
            body: parseLatex(def.def, {
                context: this.context,
                parseMode: this.parseMode,
                args: function (arg) { return args[arg]; },
                mathstyle: this.parsingContext.mathstyle,
                style: this.parsingContext.style
            })
        });
    };
    /**
     * Make an atom for the current token or token group and
     * add it to the parser's mathlist.
     * If the token is a command with arguments, will also parse the
     * arguments.
     */
    Parser.prototype.parseExpression = function () {
        var _a;
        var _b, _c, _d, _e;
        var result = (_e = (_d = (_c = (_b = this.scanEnvironment()) !== null && _b !== void 0 ? _b : this.scanModeShift()) !== null && _c !== void 0 ? _c : this.scanModeSet()) !== null && _d !== void 0 ? _d : this.scanGroup()) !== null && _e !== void 0 ? _e : this.scanLeftRight();
        if (result === null) {
            if (this.parseSupSub())
                return true;
            if (this.parseLimits())
                return true;
            result = this.scanSymbolCommandOrLiteral();
        }
        // If we have an atom to add, push it at the end of the current
        // math list. We could have no atom for tokens that were skipped,
        // a ' ' in math mode for example
        if (!result)
            return false;
        if ((0, types_1.isArray)(result))
            (_a = this.mathlist).push.apply(_a, result);
        else
            this.mathlist.push(result);
        return true;
    };
    return Parser;
}());
exports.Parser = Parser;
/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
function parseLatex(s, options) {
    var _a, _b, _c, _d;
    var args = (_a = options === null || options === void 0 ? void 0 : options.args) !== null && _a !== void 0 ? _a : undefined;
    var parser = new Parser((0, tokenizer_1.tokenize)(s, args), options === null || options === void 0 ? void 0 : options.context, {
        args: args,
        mathstyle: (_b = options === null || options === void 0 ? void 0 : options.mathstyle) !== null && _b !== void 0 ? _b : 'displaystyle',
        parseMode: (_c = options === null || options === void 0 ? void 0 : options.parseMode) !== null && _c !== void 0 ? _c : 'math',
        style: (_d = options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : {}
    });
    var atoms = [];
    while (!parser.end())
        atoms.push.apply(atoms, parser.scan(function () { return false; }));
    return atoms;
}
exports.parseLatex = parseLatex;
function validateLatex(s, options) {
    var _a;
    var parser = new Parser((0, tokenizer_1.tokenize)(s, null), options === null || options === void 0 ? void 0 : options.context, {
        mathstyle: 'displaystyle',
        parseMode: (_a = options === null || options === void 0 ? void 0 : options.parseMode) !== null && _a !== void 0 ? _a : 'math'
    });
    while (!parser.end())
        parser.scan();
    return parser.errors;
}
exports.validateLatex = validateLatex;
