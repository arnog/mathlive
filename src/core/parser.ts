import {
  Argument,
  FunctionDefinition,
  argAtoms,
  getEnvironmentDefinition,
} from '../core-definitions/definitions-utils';
import type { ColumnFormat } from '../core-atoms/array';

import { Atom, BBoxParameter, serializeAtoms } from './atom-class';

import { ErrorAtom } from '../core-atoms/error';
import { GroupAtom } from '../core-atoms/group';
import { LeftRightAtom } from '../core-atoms/leftright';
import { MacroAtom } from '../core-atoms/macro';
import { PromptAtom } from '../core-atoms/prompt';
import { PlaceholderAtom } from '../core-atoms/placeholder';
import { SpacingAtom } from '../core-atoms/spacing';
import { SubsupAtom } from '../core-atoms/subsup';
import { TextAtom } from '../core-atoms/text';

import { Mode } from './modes-utils';
import { tokenize, tokensToString } from './tokenizer';
import type {
  Style,
  ParseMode,
  Registers,
  LatexSyntaxError,
  RegisterValue,
  Dimension,
  Glue,
  ArgumentType,
  Token,
  MathstyleName,
  Environment,
} from '../public/core-types';
import type { GlobalContext } from '../core/types';

//
// - Literal (character token): a letter, digit or punctuation
// - Token: a space `<space>`, a literal, name, group or mode shift
// - Name (control sequence): a token with an initial `\` followed by
//      one or more letters /[a-zA-Z]+\*?/ or followed by a single
//      non-letter (the `operatorname*` and `hspace*` names end with
//      a `*`) or the `˜` token, e.g. `\frac`, `\alpha`, `\!`
// - Symbol: a name which is not a command, with no arguments,
//      e.g. `\pi`
// - Group: a sequence of tokens that start with `<{>` and end
//      with `<}>`
// - Argument: a single token or group after a name
// - Command:  a name followed by some optional argument, and one
//      or more required arguments
//

// Performance to check first char of string: https://jsben.ch/QLjdZ

function isLiteral(token: Token | undefined): boolean {
  return token?.length === 1 && token !== '˜';
  // return !/^<({|}|\$|\$\$|space)>$/.test(token ?? '');
}

// The `ParsingContext` is the set of properties that get 'reset' when a
// new context is entered, essentially within a `{...}` or `[...]`...
// Their values are restored when the context is exited.

export interface ParsingContext {
  parent: ParsingContext | undefined;

  // The `parse()` function for a command can modify:
  // - the `mathlist` to examine the context of the command, modify atoms
  // in the current mathlist being constructed (e.g. `\limits`) or add
  // to the mathlist (when creating a new Atom)
  // - the `style` for commands that modify the font style, color, etc...
  // - the `parseMode` for commands that shift into math or text mode
  // - the `mathstyle` for commands such as `\displaystyle`
  mathlist: Atom[];
  style: Style;

  // The parser keeps track of the state of these variable, as they can
  // influence the parsing, e.g. the `\mathchoice` command
  parseMode: ParseMode;
  mathstyle: MathstyleName;
  registers: Registers | null;

  // When in tabular mode, `"&"` is interpreted as a column separator and
  // `"\\"` as a row separator. Used for matrixes, etc...
  tabular: boolean;
}

/**
 * Transform a list of tokens into a list of atoms (a mathlist in TeX's parlance)
 *
 */
export class Parser {
  // Accumulated errors encountered while parsing
  errors: LatexSyntaxError[] = [];

  // An array of tokens generated by the lexer
  private tokens: Token[];

  // The current token to be parsed: index in `this.tokens`
  private index = 0;

  // Substitutes for `#` tokens.
  private args: null | ((arg: string) => string | undefined);

  // Counter to prevent deadlock. If `end()` is called too many
  // times (1,000) in a row for the same token, bail.
  private endCount = 0;

  private currentContext: ParsingContext;

  private context: GlobalContext;

  // smartFence  is also in GlobalContext, but it needs to be
  // overridden in some cases
  private smartFence: boolean;

  /**
   * @param tokens - An array of tokens generated by the lexer.
   *
   * Note: smartFence and registers are usually defined by the GloablContext.
   * However, in some cases they need to be overridden.
   *
   */
  constructor(
    tokens: Token[],
    context: GlobalContext,
    options: {
      args?: null | ((arg: string) => string | undefined);
      parseMode?: ParseMode;
      mathstyle?: MathstyleName;
      style?: Style;
    }
  ) {
    this.tokens = tokens;
    this.context = context;

    this.args = options.args ?? null;
    this.smartFence = context.smartFence;
    this.currentContext = {
      parent: undefined,
      mathlist: [],
      style: options.style ?? {},
      parseMode: options.parseMode ?? 'math',
      mathstyle: options.mathstyle ?? 'displaystyle',
      registers: context.registers,
      tabular: false,
    };
  }

  get rootContext(): ParsingContext {
    let context = this.currentContext;
    while (context.parent) context = context.parent;
    return context;
  }

  beginContext(options?: {
    mode?: ParseMode;
    mathstyle?: MathstyleName;
    tabular?: boolean;
  }): void {
    const current = this.currentContext;
    const newContext: ParsingContext = {
      parent: current,
      mathlist: [],
      style: { ...current.style },
      parseMode: options?.mode ?? current.parseMode,
      mathstyle: options?.mathstyle ?? current.mathstyle,
      registers: null,
      tabular: options?.tabular ?? false,
    };
    this.currentContext = newContext;
  }

  endContext(): void {
    this.currentContext = this.currentContext.parent!;
  }

  onError(err: LatexSyntaxError): void {
    this.errors.push({
      before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
      after: tokensToString(
        this.tokens.slice(Math.max(0, this.index - 10), this.index)
      ),
      ...err,
    });
  }

  get mathlist(): Atom[] {
    return this.currentContext.mathlist;
  }

  set mathlist(value: Atom[]) {
    this.currentContext.mathlist = value;
  }

  get parseMode(): ParseMode {
    return this.currentContext.parseMode;
  }

  // @revisit
  set parseMode(value: ParseMode) {
    this.currentContext.parseMode = value;
  }

  get tabularMode(): boolean {
    return this.currentContext.tabular;
  }

  get style(): Style {
    // Style is inherited
    let context: ParsingContext | undefined = this.currentContext;
    while (context) {
      if (context.style) return context.style;
      context = context.parent;
    }
    return {};
  }

  // @revisit
  set style(value: Style) {
    this.currentContext.style = value;
  }

  getRegister(name: string): RegisterValue {
    console.assert(name[0] !== '\\');
    if (name.startsWith('global '))
      return this.rootContext.registers?.[name.slice(7)] ?? 0;

    let context: ParsingContext | undefined = this.currentContext;
    while (context) {
      if (context.registers?.[name]) return context.registers[name];
      context = context.parent;
    }
    return 0;
  }

  setRegister(name: string, value: RegisterValue): void {
    if (name.startsWith('global ')) {
      // Set the global register, clear all the local ones.
      name = name.slice(7);

      let context: ParsingContext | undefined = this.currentContext;
      while (context) {
        if (context.registers?.[name]) delete context.registers[name];
        context = context.parent;
      }

      this.rootContext.registers![name] = value;
      return;
    }

    // Set the local register
    if (!this.currentContext.registers) this.currentContext.registers = {};
    this.currentContext.registers![name] = value;
  }

  /**
   * True if we've reached the end of the token stream
   */
  end(): boolean {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
  }

  next(): void {
    this.index += 1;
  }

  get(): Token {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : '';
  }

  peek(): Token | undefined {
    return this.tokens[this.index];
  }

  /**
   * @return True if the next token matches the input, and advance
   */
  match(input: string): boolean {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * Return the last atom in the mathlisst that can have a
   * subscript/superscript attached to it.
   * If there isn't one, insert a `SubsupAtom` and return it.
   */
  lastSubsupAtom(): Atom {
    let atom: Atom;
    if (this.mathlist.length > 0) {
      atom = this.mathlist[this.mathlist.length - 1];

      // If this is a `subsup` atom, it can have a `subsup` attached to it.
      if (atom.type === 'subsup') return atom;

      // An atom can have superscript/subscript attached to it if it accepts
      // limits (`\sum`, `\vec`...)
      if (atom.subsupPlacement !== undefined) return atom;
    }
    // Create a new `subsup` atom and return it
    atom = new SubsupAtom(this.context, { style: this.style });
    this.mathlist.push(atom);
    return atom;
  }

  /**
   * @return True if the next token matches the specified regular expression pattern.
   */
  hasPattern(pattern: RegExp): boolean {
    return pattern.test(this.tokens[this.index]);
  }

  hasInfixCommand(): boolean {
    const { index } = this;
    if (index < this.tokens.length && this.tokens[index].startsWith('\\')) {
      const info = this.context.getDefinition(
        this.tokens[index],
        this.parseMode
      );
      if (!info || info.definitionType === 'symbol') return false;
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) return false;

      return info.infix ?? false;
    }

    return false;
  }

  matchColumnSeparator(): boolean {
    if (!this.tabularMode) return false;
    const peek = this.peek();
    if (peek !== '&') return false;
    this.index++;
    return true;
  }

  matchRowSeparator(): boolean {
    if (!this.tabularMode) return false;
    const peek = this.peek();
    if (peek !== '\\\\' && peek !== '\\cr') return false;
    this.index++;
    return true;
  }

  /**
   * Return the appropriate value for a placeholder, either a default
   * one, or if a value was provided for #? via args, that value.
   */
  placeholder(): Atom[] {
    const placeHolderArg = this.args?.('?');
    if (!placeHolderArg) {
      return [
        new PlaceholderAtom(this.context, {
          mode: this.parseMode,
          style: this.style,
        }),
      ];
    }

    // If there is a specific value defined for the placeholder,
    // use it.
    return parseLatex(placeHolderArg, this.context, {
      parseMode: this.parseMode,
      mathstyle: 'textstyle',
    });
  }

  skipWhitespace(): void {
    while (this.match('<space>')) {}
  }

  skipUntilToken(input: string): void {
    let token = this.tokens[this.index];
    while (token && token !== input) token = this.tokens[++this.index];

    if (token === input) this.index++;
  }

  skipFiller(): void {
    while (this.match('\\relax') || this.match('<space>')) {}
  }

  /**
   * Keywords are used to specify dimensions, and for various other
   * syntactic constructs.
   *
   * Unlike commands, they are not case sensitive.
   *
   * There are 25 keywords:
   *
   * at by bp cc cm dd depth em ex fil fill filll height in minus
   * mm mu pc plus pt sp spread to true width
   *
   * TeX: 8212
   * @return true if the expected keyword is present
   */
  matchKeyword(keyword: string): boolean {
    const savedIndex = this.index;
    let done = this.end();
    let value = '';
    while (!done) {
      const token = this.get();
      if (isLiteral(token)) {
        value += token;
        done = this.end() || value.length >= keyword.length;
      } else done = true;
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) this.index = savedIndex;

    return hasKeyword;
  }

  /**
   * Return a sequence of characters as a string.
   * i.e. 'abcd' returns 'abcd'.
   * Terminates on the first non-literal token encountered
   * e.g. '<{>', '<}>' etc...
   * Will also terminate on character literal ']'
   */
  scanString(): string {
    let result = '';
    while (!this.end()) {
      const token = this.peek()!;

      if (token === ']') return result;

      if (token === '<space>') result += ' ';
      else if (token.startsWith('\\')) {
        // TeX will give a "Missing \endcsname inserted" error
        // if it encounters any command when expecting a string.
        // We're a bit more lax.
        this.onError({ code: 'unexpected-command-in-string' });
        result += token.substring(1);
      } else if (isLiteral(token)) result += token;
      else {
        // It's '<{>', '<}>', '<$>' or '<$$>
        return result;
      }
      this.next();
    }

    return result;
  }

  /**
   * Return a sequence of characters as a string.
   * Terminates on a balanced closing bracket
   * This is used by the `\ce` command
   */
  scanBalancedString(): string {
    let result = '';
    let done = this.end();
    let level = 1;
    while (!done) {
      const token = this.get();

      if (token === '<space>') result += ' ';
      else if (token === '<{>') {
        result += '{';
        level += 1;
      } else if (token === '<}>') {
        level -= 1;
        if (level > 0) result += '}';
        else this.index -= 1;
      } else if (token === '<$>') result += '$';
      else if (token === '<$$>') result += '$$';
      else result += token;

      done = level === 0 || this.end();
    }

    return result;
  }

  /**
   * Return the literal tokens, as a string, until a matching closing "}"
   * Used when handling macros
   */
  scanLiteralGroup(): string {
    if (!this.match('<{>')) return '';

    let result = '';
    let depth = 1;
    while (depth > 0 && !this.end()) {
      const token = this.get()!;
      if (token === '<}>') {
        depth -= 1;
        // Don't include final '}'
        if (depth > 0) result += '}';
      } else if (token === '<{>') {
        depth += 1;
        result += '{';
      } else {
        if (/\\[a-zA-Z]+$/.test(result) && /^[a-zA-Z]/.test(token))
          result += ' ';
        result +=
          {
            '<space>': ' ',
            '<$$>': '$$',
            '<$>': '$',
          }[token] ?? token;
      }
    }

    return result;
  }

  /**
   * Return as a number a group of characters representing a
   * numerical quantity.
   *
   * From TeX:8695 (scan_int):
   * > An integer number can be preceded by any number of spaces and `+' or
   * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
   * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
   * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
   * > an internal variable.
   */
  scanNumber(isInteger = true): null | number {
    let negative = false;
    let token = this.peek();
    while (token === '<space>' || token === '+' || token === '-') {
      this.get();
      if (token === '-') negative = !negative;
      token = this.peek();
    }

    isInteger = Boolean(isInteger);

    let radix = 10;
    let digits = /\d/;
    if (this.match("'")) {
      // Apostrophe indicates an octal value
      radix = 8;
      digits = /[0-7]/;
      isInteger = true;
    } else if (this.match('"') || this.match('x')) {
      // Double-quote indicates a hex value
      // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
      // For example: 'x3a'
      radix = 16;
      // Hex digits have to be upper-case
      digits = /[\dA-F]/;
      isInteger = true;
    } else if (this.match('`')) {
      // A backtick indicates an alphabetic constant: a letter, or a single-letter command
      token = this.get();
      if (token) {
        if (token.length === 2 && token.startsWith('\\'))
          return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);

        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }

      return null;
    }

    let value = '';
    while (this.hasPattern(digits)) value += this.get();

    // Parse the fractional part, if applicable
    // Note: TeX does accept `,` as a decimal separator see TeX: `continental_point_token`
    if (!isInteger && (this.match('.') || this.match(','))) {
      value += '.';
      while (this.hasPattern(digits)) value += this.get();
    }

    const result: number = isInteger
      ? Number.parseInt(value, radix)
      : Number.parseFloat(value);
    if (Number.isNaN(result)) return null;
    return negative ? -result : result;
  }

  /**
   * Return a dimension
   *
   * See TeX:8831
   */
  scanDimen(): Dimension | null {
    let value = this.scanNumber(false);
    if (value === null) {
      // This wasn't a number, but perhaps it's a register name?
      if (this.peek()?.startsWith('\\')) value = 1;
      else return null;
    }
    this.skipWhitespace();
    let result: Dimension;
    if (this.matchKeyword('pt')) result = { dimension: value, unit: 'pt' };
    else if (this.matchKeyword('mm')) result = { dimension: value, unit: 'mm' };
    else if (this.matchKeyword('cm')) result = { dimension: value, unit: 'cm' };
    else if (this.matchKeyword('ex')) result = { dimension: value, unit: 'ex' };
    else if (this.matchKeyword('px')) result = { dimension: value, unit: 'px' };
    else if (this.matchKeyword('em')) result = { dimension: value, unit: 'em' };
    else if (this.matchKeyword('bp')) result = { dimension: value, unit: 'bp' };
    else if (this.matchKeyword('dd')) result = { dimension: value, unit: 'dd' };
    else if (this.matchKeyword('pc')) result = { dimension: value, unit: 'pc' };
    else if (this.matchKeyword('in')) result = { dimension: value, unit: 'in' };
    else if (this.matchKeyword('mu')) result = { dimension: value, unit: 'mu' };
    else {
      if (this.peek()?.startsWith('\\')) {
        result = convertToDimension(
          this.getRegister(this.get().slice(1)),
          this.context
        ) ?? { dimension: 0 };
        result.dimension *= value;
      } else {
        if (!this.match('\\relax')) {
          // If the units are missing, TeX assumes 'pt'
          this.onError({ code: 'missing-unit' });
        }
        result = { dimension: value, unit: 'pt' };
      }
    }

    return result;
  }

  scanGlue(): Glue | null {
    const dimen = this.scanDimen();
    if (dimen === null) return null;
    const result: Glue = { glue: dimen };
    // We parse, but ignore, the optional 'plus' and 'minus'
    // arguments.

    this.skipWhitespace();
    if (this.match('\\relax')) return result;

    // 'plus', optionally followed by 'minus'
    // ('minus' cannot come before 'plus')
    // dimen or 'hfill'
    if (this.matchKeyword('plus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    this.skipWhitespace();
    if (this.match('\\relax')) return result;

    this.skipWhitespace();
    if (this.matchKeyword('minus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    return result;
  }

  scanColspec(): ColumnFormat[] | null {
    this.skipWhitespace();
    const result: ColumnFormat[] = [];
    while (!this.end() && !(this.peek() === '<}>' || this.peek() === ']')) {
      const literal = this.get();
      if (literal === 'c' || literal === 'r' || literal === 'l')
        result.push({ align: literal });
      else if (literal === '|') result.push({ separator: 'solid' });
      else if (literal === ':') result.push({ separator: 'dashed' });
      else if (literal === '@') {
        if (this.match('<{>')) {
          this.beginContext({ mode: 'math' });
          result.push({
            gap: this.scan((token) => token === '<}>'),
          });
          this.endContext();
        }

        if (!this.match('<}>')) this.onError({ code: 'unbalanced-braces' });
      }
    }

    return result;
  }

  /**
   * Scan a `\(...\)` or `\[...\]` sequence
   * @return group for the sequence or null
   */
  scanModeSet(): Atom | null {
    let mathstyle: MathstyleName | undefined = undefined;
    if (this.match('\\(')) mathstyle = 'textstyle';
    if (!mathstyle && this.match('\\[')) mathstyle = 'displaystyle';
    if (!mathstyle) return null;
    this.beginContext({ mode: 'math', mathstyle });

    const result = new GroupAtom(
      this.scan(
        (token) => token === (mathstyle === 'displaystyle' ? '\\]' : '\\)')
      ),
      this.context,
      {
        mathstyleName: mathstyle,
        latexOpen: mathstyle === 'displaystyle' ? '\\[' : '\\(',
        latexClose: mathstyle === 'displaystyle' ? '\\]' : '\\)',
        boxType: 'inner',
        break: true,
      }
    );

    if (!this.match(mathstyle === 'displaystyle' ? '\\]' : '\\)'))
      this.onError({ code: 'unbalanced-mode-shift' });

    this.endContext();
    if (result.hasEmptyBranch('body')) return null;

    return result;
  }

  /**
   * Scan a `$...$` or `$$...$$` sequence
   */
  scanModeShift(): Atom | null {
    let final: Token = '';
    if (this.match('<$>')) final = '<$>';
    if (!final && this.match('<$$>')) final = '<$$>';
    if (!final) return null;

    this.beginContext({
      mode: 'math',
      mathstyle: '<$>' ? 'textstyle' : 'displaystyle',
    });

    const result = new GroupAtom(
      this.scan((token: Token) => token === final),
      this.context,
      {
        mathstyleName: final === '<$>' ? 'textstyle' : 'displaystyle',
        latexOpen: final === '<$>' ? '$ ' : '$$ ',
        latexClose: final === '<$>' ? ' $' : ' $$',
        break: true,
      }
    );

    if (!this.match(final)) this.onError({ code: 'unbalanced-mode-shift' });

    this.endContext();
    if (result.hasEmptyBranch('body')) return null;
    return result;
  }

  /**
   * Scan a \begin{env}...\end{end} sequence
   */
  scanEnvironment(): Atom | null {
    // An environment starts with a \begin command
    if (!this.match('\\begin')) return null;

    // The \begin command is immediately followed by the environment
    // name, as a string argument
    const envName = this.scanArgument('string') as Environment;
    if (!envName) return null;
    const def = getEnvironmentDefinition(envName);
    if (!def) {
      this.onError({
        code: 'unknown-environment',
        arg: envName,
      });
      return null;
    }

    // If the environment has some arguments, parse them
    const args: (null | Argument)[] = [];
    if (def.params) {
      for (const parameter of def.params) {
        // Parse an argument
        if (parameter.isOptional) {
          // If it's not present, parseOptionalArgument returns null,
          // but push it on the list of arguments anyway.
          // The null value will be interpreted as unspecified
          // optional value by the command parse function.
          args.push(this.scanOptionalArgument(parameter.type));
        } else {
          const arg = this.scanArgument(parameter.type);
          if (!arg) {
            this.onError({
              code: 'missing-argument',
              arg: envName,
            });
          }

          args.push(arg);
        }
      }
    }

    this.beginContext({ tabular: def.tabular });

    const array: Atom[][][] = [];
    const rowGaps: Dimension[] = [];
    let row: Atom[][] = [];
    let done = false;
    do {
      if (this.end()) {
        this.onError({ code: 'unbalanced-environment', arg: envName });
        done = true;
      }

      if (!done && this.match('\\end')) {
        if (this.scanArgument('string') !== envName) {
          this.onError({
            code: 'unbalanced-environment',
            arg: envName,
          });
        }

        done = true;
      }

      if (!done) {
        if (this.matchColumnSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
        } else if (this.matchRowSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
          let gap: Dimension | null = null;
          this.skipWhitespace();
          if (this.match('[')) {
            gap = this.scanDimen();
            this.skipWhitespace();
            this.match(']');
          }

          rowGaps.push(gap ?? { dimension: 0 });
          array.push(row);
          row = [];
        } else {
          this.mathlist.push(
            ...this.scan(
              (token: Token) =>
                token === '<}>' ||
                token === '&' ||
                token === '\\end' ||
                token === '\\cr' ||
                token === '\\\\'
            )
          );
        }
      }
    } while (!done);

    row.push(this.mathlist);
    if (row.length > 0) array.push(row);

    this.endContext();

    return def.createAtom(this.context, envName, array, rowGaps, args);
  }

  /**
   * Parse an expression: a literal, or a command and its arguments
   */
  scanExpression(): Atom[] | null {
    const savedList = this.mathlist;
    this.mathlist = [];
    if (this.parseExpression()) {
      const result = this.mathlist;
      this.mathlist = savedList;
      return result;
    }
    this.mathlist = savedList;
    return null;
  }

  /**
   * Parse a sequence until a group end marker, such as
   * `}`, `\end`, `&`, etc...
   *
   * Returns an array of atoms or an empty array if the sequence
   * terminates right away.
   *
   * @param done - A predicate indicating if a token signals the end of a
   * group
   */
  scan(done?: (token: Token) => boolean): Atom[] {
    this.beginContext();

    // Default group end marker
    if (!done) done = (token: Token) => token === '<}>';

    // To handle infix commands, we'll keep track of their prefix
    // (tokens coming before them) and their arguments
    let infix: Token = '';
    let infixInfo: FunctionDefinition | null = null;
    let infixArgs: Atom[][] = [];
    let prefix: Atom[] | null = null;
    console.assert(this.mathlist.length === 0);
    const saveAtoms = this.mathlist;
    this.mathlist = [];
    while (!this.end() && !done(this.peek() ?? '')) {
      if (this.hasInfixCommand() && !infix) {
        // The next token is an infix and we have not seen one yet
        // (there can be only one infix command per implicit group).
        infix = this.get();
        // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode
        infixInfo = this.context.getDefinition(
          infix,
          'math'
        ) as FunctionDefinition;
        if (infixInfo) infixArgs = this.scanArguments(infixInfo)[1] as Atom[][];

        // Save the math list so far and start a new one
        prefix = this.mathlist;
        this.mathlist = [];
      } else this.parseExpression();
    }

    let result: Atom[];
    if (infix) {
      console.assert(Boolean(infixInfo));
      infixArgs.unshift(this.mathlist); // Suffix
      this.mathlist = saveAtoms;
      if (prefix) infixArgs.unshift(prefix);
      result = [
        infixInfo!.createAtom!(infix, this.context, this.style, infixArgs),
      ];
    } else {
      result = this.mathlist;
      this.mathlist = saveAtoms;
    }

    this.endContext();

    return result;
  }

  /**
   * Parse a group enclosed in a pair of braces: `{...}`.
   *
   * Return either a group Atom or null if not a group.
   *
   * Return a group Atom with an empty body if an empty
   * group (i.e. `{}`).
   */
  scanGroup(): Atom | null {
    if (this.parseMode === 'text') {
      if (this.match('<{>')) {
        return new Atom('text', this.context, {
          value: '{',
          mode: 'text',
          style: this.style,
        });
      }
      if (this.match('<}>')) {
        return new Atom('text', this.context, {
          value: '}',
          mode: 'text',
          style: this.style,
        });
      }
      return null;
    }
    if (!this.match('<{>')) return null;

    const body = this.scan((token) => token === '<}>');
    if (!this.match('<}>')) this.onError({ code: 'unbalanced-braces' });

    // Non-empty groups introduce a break in the
    // inter-box spacing. Empty groups (`{}`) do not.

    const result = new GroupAtom(body, this.context, {
      break: body.length > 1,
      mode: this.parseMode,
      latexOpen: '{',
      latexClose: '}',
    });

    return result;
  }

  scanSmartFence(): Atom | null {
    this.skipWhitespace();
    if (!this.match('(')) return null;
    // We've found an open paren... Convert to a `\left...\right`
    this.beginContext();
    let nestLevel = 1;
    while (!this.end() && nestLevel !== 0) {
      if (this.match('(')) nestLevel += 1;
      if (this.match(')')) nestLevel -= 1;
      if (nestLevel !== 0) this.parseExpression();
    }

    if (nestLevel === 0) this.match(')');
    const result = new LeftRightAtom('', this.mathlist, this.context, {
      leftDelim: '(',
      rightDelim: nestLevel === 0 ? ')' : '?',
    });

    this.endContext();
    return result;
  }

  /**
   * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
   *
   * @return The delimiter (as a character or command) or null
   */
  scanDelim(): string | null {
    this.skipWhitespace();
    const token = this.peek();
    if (!token) {
      this.onError({ code: 'unexpected-end-of-string' });
      return null;
    }

    if (!isLiteral(token) && !token.startsWith('\\')) return null;

    this.next();

    const info = this.context.getDefinition(token, 'math');
    if (!info) {
      this.onError({ code: 'unknown-command', arg: token });
      return null;
    }

    if (
      info.definitionType === 'function' &&
      info.ifMode &&
      !info.ifMode.includes(this.parseMode)
    ) {
      this.onError({ code: 'unexpected-delimiter', arg: token });
      return null;
    }

    if (
      info.definitionType === 'symbol' &&
      (info.type === 'mopen' || info.type === 'mclose')
    )
      return token;

    // Some symbols are not of type mopen/mclose, but are still
    // valid delimiters...
    // '?' is a special delimiter used as a 'placeholder'
    // (when the closing delimiter is displayed greyed out)
    if (
      /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
        token
      )
    )
      return token;

    this.onError({ code: 'unexpected-delimiter', arg: token });
    return null;
  }

  /**
   * Parse a `/left.../right` sequence.
   *
   * Note: the `/middle` command can occur multiple times inside a
   * `/left.../right` sequence, and is handled separately.
   *
   * Return either an atom of type `"leftright"` or null
   */
  scanLeftRight(): Atom | null {
    if (this.match('\\right')) {
      this.onError({ code: 'unbalanced-braces' });
      return new ErrorAtom('\\right', this.context);
    }
    if (this.match('\\mright')) {
      this.onError({ code: 'unbalanced-braces' });
      return new ErrorAtom('\\mright', this.context);
    }

    let close = '\\right';
    if (!this.match('\\left')) {
      if (!this.match('\\mleft')) return null;
      close = '\\mright';
    }

    const leftDelim = this.scanDelim();
    if (!leftDelim) {
      this.onError({ code: 'unexpected-delimiter' });
      return new ErrorAtom(
        close === '\\right' ? '\\left' : '\\mleft',
        this.context
      );
    }

    this.beginContext();

    while (!this.end() && !this.match(close)) this.parseExpression();

    const body = this.mathlist;
    this.endContext();

    // If we've reached the end and there was no `\right` or
    // there isn't a valid delimiter after `\right`, we'll
    // consider the `\right` missing and set the `rightDelim` to undefined
    const rightDelim = this.scanDelim() ?? '.';

    return new LeftRightAtom(
      close === '\\right' ? 'left...right' : 'mleft...mright',
      body,
      this.context,
      {
        leftDelim,
        rightDelim,
        style: this.style,
      }
    );
  }

  /**
   * Parse a subscript/superscript: `^` and `_`.
   *
   * Modify the last atom accordingly, or create a new 'subsup' carrier.
   *
   */
  parseSupSub(): boolean {
    // No sup/sub in text or command mode.
    if (this.parseMode !== 'math') return false;

    // Apply the subscript/superscript to the last rendered atom.
    // If none is present (beginning of the list, i.e. `{^2}`,
    // an empty atom will be created, equivalent to `{{}^2}`
    let token = this.peek();
    if (token !== '^' && token !== '_' && token !== "'") return false;

    while (token === '^' || token === '_' || token === "'") {
      if (this.match("'")) {
        if (this.match("'")) {
          // A single quote, twice, is equivalent to '^{\doubleprime}'
          this.lastSubsupAtom().addChild(
            new Atom('mord', this.context, {
              command: '\\doubleprime',
              mode: 'math',
              value: '\u2032\u2032', // "\u2033" displays too high
            }),
            'superscript'
          );
        } else {
          // A single quote (prime) is equivalent to '^{\prime}'
          this.lastSubsupAtom().addChild(
            new Atom('mord', this.context, {
              command: '\\prime',
              mode: 'math',
              value: '\u2032',
            }),
            'superscript'
          );
        }
      } else if (this.match('^') || this.match('_')) {
        const arg = this.scanArgument('expression');
        if (arg) {
          this.lastSubsupAtom().addChildren(
            argAtoms(arg),
            token === '_' ? 'subscript' : 'superscript'
          );
        } else {
          this.lastSubsupAtom().createBranch(
            token === '_' ? 'subscript' : 'superscript'
          );
        }
      }

      token = this.peek();
    }

    return true;
  }

  /**
   * Parse a `\limits` or `\nolimits` command.
   *
   * This will change the placement of limits to be either above or below
   * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
   *
   * This overrides the calculation made for the placement, which is usually
   * dependent on the displaystyle (`textstyle` prefers `\nolimits`, while
   * `displaystyle` prefers `\limits`).
   */
  parseLimits(): boolean {
    // Note: `\limits`, `\nolimits` and `\displaylimits` are only applicable \
    // after an operator.
    // We skip them and ignore them if they are after something other
    // than an operator (TeX throws an error)

    const isLimits = this.match('\\limits');
    const isNoLimits = !isLimits && this.match('\\nolimits');
    const isDisplayLimits =
      !isNoLimits && !isLimits && this.match('\\displaylimits');

    if (!isLimits && !isNoLimits && !isDisplayLimits) return false;

    const opAtom =
      this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;

    if (opAtom === null || opAtom.type !== 'mop') return false;

    if (isLimits) {
      opAtom.subsupPlacement = 'over-under';
      // Record that the limits was set through an explicit command
      // so we can generate the appropriate LaTeX later
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    if (isNoLimits) {
      opAtom.subsupPlacement = 'adjacent';
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    if (isDisplayLimits) {
      opAtom.subsupPlacement = 'auto';
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    return false;
  }

  scanArguments(
    info: Partial<FunctionDefinition>
  ): [ParseMode | undefined, (null | Argument)[]] {
    if (!info?.params) return [undefined, []];
    let explicitGroup: ParseMode | undefined = undefined;
    const args: (null | Argument)[] = [];
    let i = info.infix ? 2 : 0;
    while (i < info.params.length) {
      const parameter = info.params[i];
      // Parse an argument
      if (parameter.type === 'rest') {
        args.push(
          this.scan(
            (token: Token) =>
              token === '<}>' ||
              token === '&' ||
              token === '\\end' ||
              token === '\\cr' ||
              token === '\\\\'
          )
        );
      } else if (parameter.isOptional)
        args.push(this.scanOptionalArgument(parameter.type));
      else if (parameter.type.endsWith('*')) {
        // For example 'math*'.
        // In this case, indicate that a 'yet-to-be-parsed'
        // argument (and 'explicit group') is present
        explicitGroup = parameter.type.slice(0, -1) as ParseMode;
      } else {
        const arg = this.scanArgument(parameter.type);
        if (arg !== null) args.push(arg);
        else {
          // Report an error
          this.onError({ code: 'missing-argument' });
          switch (parameter.type) {
            case 'number':
              // case 'dimen':
              // case 'glue':
              args.push(0);
              break;
            case 'dimen':
              args.push({ dimension: 0, unit: 'pt' });
              break;
            case 'glue':
              args.push({ glue: { dimension: 0, unit: 'pt' } });
              break;
            case 'string':
            case 'balanced-string':
              args.push('');
              break;
            case 'delim':
              args.push('.');
              break;
            case 'colspec':
              args.push('llllllllll');
              break;
            case 'auto':
            default:
              args.push(this.placeholder());
              break;
          }
        }
      }

      i += 1;
    }

    return [explicitGroup, args];
  }

  scanSymbolOrLiteral(): Atom[] | null {
    const token = this.peek();
    if (!token) return null;
    this.next();
    let result: Atom | null;

    //
    // Is it a literal?
    //
    if (isLiteral(token)) {
      const result = Mode.createAtom(this.parseMode, token, this.context, {
        ...this.style,
      });
      return result ? [result] : null;
    }

    //
    // Is this a macro?
    //
    result = this.scanMacro(token);
    if (result) return [result];

    if (token.startsWith('\\')) {
      const info = this.context.getDefinition(token, this.parseMode);
      if (!info) {
        this.onError({ code: 'unknown-command', arg: token });
        return [new ErrorAtom(token, this.context)];
      }
      if (info.definitionType === 'symbol') {
        //
        // The command is a simple symbol (no arguments)
        //
        const style = { ...this.style };
        if (info.variant) style.variant = info.variant;

        result = new Atom(info.type, this.context, {
          command: token,
          style,
          value: String.fromCodePoint(info.codepoint),
          mode: this.parseMode,
        });
        result.verbatimLatex = token;
      } else if (info.applyMode || info.applyStyle || info.infix) {
        // The command modifies the mode or style: can't use here
        this.onError({ code: 'invalid-command', arg: token });
        return [new ErrorAtom(token, this.context)];
      } else if (info.createAtom)
        result = info.createAtom(token, this.context, this.style, []);
    }
    return result ? [result] : null;
  }

  /**
   * Parse a "math field" (in the TeX parlance), an argument to a
   * command.
   *
   * In LaTeX, the arguments of commands can either:
   * - require braces: e.g. `\hbox{\alpha}`
   * - prohibit braces: e.g. `\vskip 12pt`
   * - have optional braces, e.g. `\sqrt\frac12`. The behavior with and without
   * braces may be different. Example: `\not=` vs `\not{=}` render differently
   *
   * This is reflected by the argument type.
   * - Prohibited braces:
   *  - 'delim'
   * - Optional braces:
   *  - 'text': required braces (or when 'auto' means 'text')
   *  - 'math' (or when 'auto' means 'math')
   *  - 'expression'
   *  - 'number', 'glue', 'dimen'
   * - Required braces:
   *  - 'string', 'balanced-string',
   *  - 'colspec'
   *  - 'bbox' (require square brackets)
   *
   * An argument can either be a single atom or  a sequence of atoms
   * enclosed in braces.
   *
   */
  scanArgument(type: 'auto'): null | Atom[] | { group: Atom[] };
  scanArgument(type: ParseMode): null | Atom[] | { group: Atom[] };
  scanArgument(type: 'expression'): null | Atom[] | { group: Atom[] };
  scanArgument(type: 'balanced-string'): null | string;
  scanArgument(type: 'colspec'): null | ColumnFormat[];
  scanArgument(type: 'delim'): null | string;
  scanArgument(type: 'dimen'): null | number;
  scanArgument(type: 'number'): null | number;
  scanArgument(type: 'glue'): null | number;
  scanArgument(type: 'string'): null | string;
  scanArgument(type: ArgumentType): null | Argument;
  scanArgument(type: ArgumentType): null | Argument {
    this.skipFiller();
    if (type === 'auto') type = this.parseMode;

    //
    // Argument without braces
    //
    if (!this.match('<{>')) {
      if (type === 'dimen') return this.scanDimen();
      if (type === 'glue') return this.scanGlue();
      if (type === 'number') return this.scanNumber();
      if (type === 'delim') return this.scanDelim() ?? '.';
      if (type === 'expression') return this.scanExpression();
      if (type === 'math') return this.scanSymbolOrLiteral();
      if (type === 'text') {
        this.beginContext({ mode: 'text' });
        const result = this.scanSymbolOrLiteral();
        this.endContext();
        return result;
      }

      return null;
    }

    //
    // Braced argument
    //

    if (type === 'text') {
      this.beginContext({ mode: type });
      this.index -= 1;
      const s = this.scanLiteralGroup();
      const atoms = parseLatex(s, this.context, {
        parseMode: 'text',
        style: this.currentContext.style,
      });
      this.endContext();
      return { group: atoms };
    }

    if (type === 'math') {
      this.beginContext({ mode: type });
      do this.mathlist.push(...this.scan());
      while (!this.match('<}>') && !this.end());
      const atoms = this.mathlist;
      this.endContext();
      return { group: atoms };
    }

    let result: null | Argument = null;
    if (type === 'expression') {
      this.beginContext({ mode: 'math' });
      do this.mathlist.push(...this.scan());
      while (!this.match('<}>') && !this.end());
      const atoms = this.mathlist;
      this.endContext();
      return { group: atoms };
    }

    if (type === 'string') result = this.scanString();
    else if (type === 'balanced-string') result = this.scanBalancedString();
    else if (type === 'colspec') result = this.scanColspec();
    else if (type === 'dimen') result = this.scanDimen();
    else if (type === 'glue') result = this.scanGlue();
    else if (type === 'number') result = this.scanNumber();

    this.skipUntilToken('<}>');

    return result;
  }

  scanOptionalArgument(argType: ArgumentType): Argument | null {
    argType = argType === 'auto' ? this.parseMode : argType;
    this.skipFiller();
    if (!this.match('[')) return null;
    let result: Argument | null = null;
    while (!this.end() && !this.match(']')) {
      if (argType === 'string') result = this.scanString();
      else if (argType === 'dimen') result = this.scanDimen();
      else if (argType === 'glue') result = this.scanGlue();
      else if (argType === 'number') result = this.scanNumber();
      else if (argType === 'colspec') result = this.scanColspec();
      else if (argType === 'bbox') {
        // The \bbox command takes a very particular argument:
        // a comma delimited list of up to three arguments:
        // a color, a dimension and a string.
        // Split the string by comma delimited sub-strings, ignoring commas
        // that may be inside (). For example"x, rgb(a, b, c)" would return
        // ['x', 'rgb(a, b, c)']
        const list = this.scanString()
          .toLowerCase()
          .trim()
          .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
        const bboxParameter: BBoxParameter = {};
        for (const element of list) {
          const color = this.context.backgroundColorMap?.(element);
          if (color) bboxParameter.backgroundcolor = color;
          else {
            const m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
            if (m) bboxParameter.padding = m[0];
            else {
              const m = element.match(/^\s*border\s*:\s*(.*)/);
              if (m) bboxParameter.border = m[1];
            }
          }
        }

        result = bboxParameter;
      } else if (argType === 'math') {
        this.beginContext({ mode: 'math' });
        result = this.mathlist.concat(this.scan((token) => token === ']'));
        this.endContext();
      }
    }

    return result;
  }

  /** Parse a symbol or a command and its arguments */
  scanSymbolOrCommand(command: string): Atom[] | null {
    if (command === '\\placeholder') {
      const id = this.scanOptionalArgument('string') as string;
      // default value is legacy, ignored if there is a body
      // We need to check if second argument is `correct`, `incorrect` or to be interpreted as math
      const defaultValue = this.scanOptionalArgument('math') as Atom[];
      const defaultAsString = serializeAtoms(defaultValue, {
        defaultMode: 'math',
      });
      let defaultAtoms = [] as Atom[];

      let correctness;

      if (!correctness && defaultAsString === 'correct')
        correctness = 'correct';
      else if (!correctness && defaultAsString === 'incorrect')
        correctness = 'incorrect';
      else if (defaultAsString !== '') defaultAtoms = defaultValue;

      // const locked =  === 'locked';
      const locked = this.scanOptionalArgument('string') === 'locked';
      const value = this.scanArgument('auto');
      let body: Atom[];
      if (value && Array.isArray(value) && value.length > 0) body = value;
      else if (value && typeof value === 'object' && 'group' in value)
        body = value.group;
      else body = defaultAtoms;
      if (id) {
        return [
          new PromptAtom(
            this.context,
            id,
            correctness,
            // locked,
            locked,
            body ?? defaultAtoms,
            {
              mode: this.parseMode,
              style: this.style,
            }
          ),
        ];
      }
      return [
        new PlaceholderAtom(this.context, {
          mode: this.parseMode,
          placeholderId: id,
          style: this.style,
        }),
      ];
    }

    let result: Atom | null = null;

    if (command === '\\char') {
      const initialIndex = this.index;
      let codepoint = Math.floor(this.scanNumber(true) ?? Number.NaN);
      if (!Number.isFinite(codepoint) || codepoint < 0 || codepoint > 0x10ffff)
        codepoint = 0x2753; // BLACK QUESTION MARK

      result = new Atom(
        this.parseMode === 'math' ? 'mord' : 'text',
        this.context,
        {
          command: '\\char',
          mode: this.parseMode,
          value: String.fromCodePoint(codepoint),
          serialize: (atom) =>
            atom.verbatimLatex ??
            `\\char"${atom.value!.codePointAt(0)!.toString(16).toUpperCase()}`,
        }
      );
      result.verbatimLatex =
        '\\char' + tokensToString(this.tokens.slice(initialIndex, this.index));

      return [result];
    }

    if (command === '\\hskip' || command === '\\kern') {
      const width = this.scanGlue();
      if (!width) return null;
      return [new SpacingAtom(command, this.style, this.context, width)];
    }

    // Is this a macro?
    result = this.scanMacro(command);
    if (result) return [result];

    // This wasn't a macro, so let's see if it's a regular command
    const info = this.context.getDefinition(command, this.parseMode);

    // An unknown command, or a command not available in this mode
    if (!info) {
      this.onError({ code: 'unknown-command', arg: command });
      if (this.parseMode === 'text') {
        return [...command].map(
          (c) =>
            new Atom('text', this.context, {
              value: c,
              mode: 'text',
              style: this.style,
            })
        );
      }
      return [new ErrorAtom(command, this.context)];
    }

    const initialIndex = this.index;

    if (info.definitionType === 'symbol') {
      const style = { ...this.style };

      // Override the variant if an explicit variant is provided
      if (info.variant) style.variant = info.variant;

      result = new Atom(info.type, this.context, {
        command,
        style,
        value: String.fromCodePoint(info.codepoint),
        mode: this.parseMode,
      });
    } else {
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
        // Command not applicable in this mode: ignore it (TeX behavior)
        // (for example `\Huge` in math mode
        return [];
      }

      // Parse the arguments.
      //
      // If `deferredArg` is not empty, the content after the command
      // will be parsed *after* the command has been initially processed
      // (atom creation or style application) and passed to
      //
      // This is used for commands such as \textcolor{color}{content}
      // that need to apply the color to the content *after* the
      // style has been changed.
      //
      // In definitions, this is indicated with a parameter type
      // thats ends with a '*' ('math*', 'auto*').

      const savedMode = this.parseMode;
      if (info.applyMode) this.parseMode = info.applyMode;

      const [deferredArg, args] = this.scanArguments(info);
      this.parseMode = savedMode;

      if (info.applyMode && !info.applyStyle && !info.createAtom)
        return argAtoms(args[0]);

      if (info.infix) {
        // Infix commands should be handled in scanImplicitGroup
        // If we find an infix command here, it's a syntax error
        // (second infix command in a group) and should be ignored.
        this.onError({
          code: 'too-many-infix-commands',
          arg: command,
        });
        return null;
      }

      //  Invoke the createAtom() function if present
      if (typeof info.createAtom === 'function') {
        result = info.createAtom(command, this.context, this.style, args);
        if (deferredArg)
          result!.body = argAtoms(this.scanArgument(deferredArg));
      } else if (typeof info.applyStyle === 'function') {
        const style = info.applyStyle(command, this.context, args);
        // No type provided -> the parse function will modify
        // the current style rather than create a new Atom.
        const savedMode = this.parseMode;
        if (info.applyMode) {
          // Change to 'text' (or 'math') mode if necessary
          this.parseMode = info.applyMode;
        }

        // If a deferred arg is expected, process it now
        if (deferredArg) {
          // Create a temporary style
          const saveStyle = this.style;
          this.style = { ...this.style, ...style };
          const atoms = this.scanArgument(deferredArg);
          this.style = saveStyle;
          this.parseMode = savedMode;
          return argAtoms(atoms);
        }

        // Merge the new style info with the current style
        this.style = { ...this.style, ...style };
        this.parseMode = savedMode;
      } else {
        result = new Atom('mop', this.context, {
          command: info.command ?? command,
          style: { ...this.style },
          value: command,
          mode: info.applyMode ?? this.parseMode,
        });
      }
    }
    if (
      result instanceof Atom &&
      result.verbatimLatex === undefined &&
      !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)
    ) {
      result.verbatimLatex =
        (result.command ?? '') +
        tokensToString(this.tokens.slice(initialIndex, this.index));
      if (result.verbatimLatex.length === 0) result.verbatimLatex = undefined;

      if (result.isFunction && this.smartFence) {
        // The command was a function that may be followed by
        // an argument, like `\sin(`
        const smartFence = this.scanSmartFence();
        if (smartFence) return [result, smartFence];
      }
    }

    return result ? [result] : null;
  }

  scanSymbolCommandOrLiteral(): Atom[] | null {
    const token = this.get();
    if (!token) return null;

    if (isLiteral(token)) {
      const result = Mode.createAtom(this.parseMode, token, this.context, {
        ...this.style,
      });
      if (!result) return null;

      if (result.isFunction && this.smartFence) {
        // The atom was a function that may be followed by
        // an argument, like `f(`.
        const smartFence = this.scanSmartFence();
        if (smartFence) return [result, smartFence];
      }

      return [result];
    }

    if (token.startsWith('\\')) return this.scanSymbolOrCommand(token);

    if (token === '<space>') {
      if (this.parseMode === 'text')
        return [new TextAtom(' ', ' ', this.style, this.context)];

      return null;
    }

    if (token === '<}>') this.onError({ latex: '', code: 'unbalanced-braces' });
    else {
      this.onError({
        latex: '',
        code: 'unexpected-token',
        arg: token,
      });
    }

    return null;
  }

  /**
   * Attempt to scan the macro name and return a macro atom if
   * successful.
   */
  scanMacro(macro: string): Atom | null {
    const def = this.context.getMacro(macro);
    if (!def) return null;
    const initialIndex = this.index;
    const argCount = def.args!;

    // Carry forward the placeholder argument, if any.
    const args: Record<string, string | undefined> = { '?': this.args?.('?') };
    // Parse each argument group as a string. We don't know yet
    // what the proper parse mode is, so defer parsing till later
    // when invoking `parseLatex`
    for (let i = 1; i <= argCount; i++) args[i] = this.scanLiteralGroup();

    // Group the result of the macro expansion
    return new MacroAtom(macro, this.context, {
      expand: def.expand,
      captureSelection: def.captureSelection,
      args: tokensToString(this.tokens.slice(initialIndex, this.index)),
      body: parseLatex(def.def, this.context, {
        parseMode: this.parseMode,
        args: (arg) => args[arg],
        mathstyle: this.currentContext.mathstyle,
        style: this.currentContext.style,
      }),
    });
  }

  /**
   * Make an atom for the current token or token group and
   * add it to the parser's mathlist.
   * If the token is a command with arguments, will also parse the
   * arguments.
   */
  parseExpression(): boolean {
    let result: null | Atom | Atom[] =
      this.scanEnvironment() ??
      this.scanModeShift() ??
      this.scanModeSet() ??
      this.scanGroup() ??
      this.scanLeftRight();

    if (result === null) {
      if (this.parseSupSub()) return true;
      if (this.parseLimits()) return true;
      result = this.scanSymbolCommandOrLiteral();
    }

    // If we have an atom to add, push it at the end of the current
    // math list. We could have no atom for tokens that were skipped,
    // a ' ' in math mode for example
    if (!result) return false;
    if (Array.isArray(result)) this.mathlist.push(...result);
    else this.mathlist.push(result);
    return true;
  }
}

/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
export function parseLatex(
  s: string,
  context: GlobalContext,
  options?: {
    parseMode?: ParseMode;
    args?: null | ((arg: string) => string | undefined);
    mathstyle?: MathstyleName;
    style?: Style;
  }
): Atom[] {
  const args = options?.args ?? null;
  const parser = new Parser(tokenize(s, args), context, {
    args,
    mathstyle: options?.mathstyle ?? 'displaystyle',
    parseMode: options?.parseMode ?? 'math',
    style: options?.style ?? {},
  });

  const atoms: Atom[] = [];
  while (!parser.end()) atoms.push(...parser.scan(() => false));
  return atoms;
}

export function validateLatex(
  s: string,
  context: GlobalContext,
  options?: { parseMode?: ParseMode }
): LatexSyntaxError[] {
  const parser = new Parser(tokenize(s, null), context, {
    args: null,
    mathstyle: 'displaystyle',
    parseMode: options?.parseMode ?? 'math',
  });

  while (!parser.end()) parser.scan();
  return parser.errors;
}

export function convertToGlue(
  value: RegisterValue,
  context: GlobalContext
): null | Glue {
  // If it's already a Glue, return it.
  if (typeof value === 'object' && 'glue' in value) return value;

  if (typeof value === 'object' && 'dimension' in value) return { glue: value };

  if (typeof value === 'number') return { glue: { dimension: value } };

  // It's a string, attempt to parse it.
  const parser = new Parser(tokenize(value), context, {});
  return parser.scanGlue();
}

/**  Return a dimension. */
export function convertToDimension(
  value: RegisterValue,
  context: GlobalContext
): null | Dimension {
  if (typeof value === 'number') return { dimension: value, unit: 'pt' };

  if (typeof value === 'object' && 'glue' in value) value = value.glue;

  if (typeof value === 'object' && 'dimension' in value) return value;

  // It's a string
  const parser = new Parser(tokenize(value), context, {});
  return parser.scanDimen();
}
