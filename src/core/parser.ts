import { isArray } from '../common/types';

import {
    getEnvironmentDefinition,
    getInfo,
    unicodeCharToLatex,
    MacroDictionary,
} from './definitions';
import { stringToColor } from './color';
import { convertDimenToEm } from './font-metrics';
import { Token, tokenize } from './tokenizer';
import { Atom, Colspec, BBoxParam } from './atom';
import { parseTokens, tokensToString } from './modes-utils';
import { FunctionDefinition, SymbolDefinition } from './definitions-utils';
import {
    ErrorListener,
    MacroDefinition,
    Style,
    ParserErrorCode,
} from '../public/core';
import { ParseModePrivate } from './context';

// Performance to check first char of string: https://jsben.ch/QLjdZ

function isLiteral(token: Token): boolean {
    return !/^<({|}|\$|\$\$|space)>$/.test(token);
}

/**
 * Transform a list of tokens into a list of atoms.
 *

 * @property tokens - An array of tokens generated by the lexer.
 * @property args - Optional arguments to substitute the `#` token.
 * @property macros - A dictionary of objects, index by the name of
 * the macro, with the following keys:
 *    * args: an integer, the number of arguments, default 0. They can be referenced as #0,
 *       #1, #2... inside the definition of the macro
 *    * def: a string, the definition of the macro, which can reference other macros
 * @property index - The current token to be parsed: index in `this.tokens`
 * @property atoms - Accumulated result of the parsing by
 * `parseAtom()`
 * @property style - The font, weight, color, etc. to apply to the
 * upcoming tokens
 * @property parseMode - The parse mode indicates the syntax rules to
 * use to parse the upcoming tokens.
 * @property tabularMode - When in tabular mode, `'&'` is interpreted as
 *  a column separator and `'\'` as a row separator. Used for matrixes, etc...
 * @property endCount - Counter to prevent deadlock. If `end()` is
 * called too many times (1,000) in a row for the same token, bail.
 */
class Parser {
    tokens: Token[];
    index = 0;

    args: null | (string | Atom[])[];
    macros: MacroDictionary;

    style: Style = {};
    parseMode: ParseModePrivate = 'math';
    smartFence = false;
    tabularMode = false; // For arrays, matrix, etc.: ifferent parsing rules apply.

    atoms: Atom[] = [];

    endCount = 0;
    onError: ErrorListener<ParserErrorCode>;

    /**
     * @param tokens - An array of tokens generated by the lexer.
     * @param args - An optional list of arguments. `#n` tokens will be
     * substituted with the corresponding element in the args object. This is used
     * when parsing macros.
     */
    constructor(
        tokens: Token[],
        args: null | (string | Atom[])[],
        macros: MacroDictionary,
        onError: ErrorListener<ParserErrorCode>
    ) {
        this.tokens = tokens;
        this.args = args;
        this.macros = macros;
        this.onError = (err): void =>
            onError({
                before: tokensToString(
                    this.tokens.slice(this.index, this.index + 10)
                ),
                after: tokensToString(
                    this.tokens.slice(Math.max(0, this.index - 10), this.index)
                ),
                ...err,
            });
    }
    swapAtoms(newAtoms: Atom[] = []): Atom[] {
        const result = this.atoms;
        this.atoms = newAtoms;
        return result;
    }
    swapParseMode(mode: ParseModePrivate): ParseModePrivate {
        const result = this.parseMode;
        this.parseMode = mode;
        return result;
    }
    /**
     * True if we've reached the end of the token stream
     */
    end(): boolean {
        // To prevent a deadlock, count how many times end() is called without the
        // index advancing. If it happens more than 1,000 times in a row,
        // assume something is broken and pretend the stream is finished.
        this.endCount++;
        return this.index >= this.tokens.length || this.endCount > 1000;
    }
    get(): Token {
        this.endCount = 0;
        return this.index < this.tokens.length ? this.tokens[this.index++] : '';
    }
    peek(): Token {
        return this.tokens[this.index];
    }
    /**
     * @return True if the next token matches the input, and advance
     */
    match(input: string): boolean {
        if (this.tokens[this.index] === input) {
            this.index++;
            return true;
        }
        return false;
    }
    /**
     * Return the last atom that can have a subsup attached to it.
     * If there isn't one, insert a `msubsup` and return it.
     */
    lastSubsupAtom(): Atom {
        const lastAtom =
            this.atoms.length === 0
                ? undefined
                : this.atoms[this.atoms.length - 1];
        if (
            !lastAtom ||
            (lastAtom.type !== 'mop' &&
                lastAtom.type !== 'leftright' &&
                lastAtom.type !== 'msubsup')
        ) {
            if (!lastAtom?.limits || lastAtom?.limits === 'nolimits') {
                this.atoms.push(new Atom(this.parseMode, 'msubsup', '\u200b'));
            }
        }
        return this.atoms[this.atoms.length - 1];
    }

    /**
     * @return True if the next token matches the specified regular expression pattern.
     */
    hasPattern(pattern: RegExp): boolean {
        return pattern.test(this.tokens[this.index]);
    }

    hasInfixCommand(): boolean {
        const index = this.index;
        if (index < this.tokens.length && this.tokens[index][0] === '\\') {
            const info = getInfo(
                this.tokens[index],
                this.parseMode,
                this.macros
            );
            if (info?.mode && !info.mode.includes(this.parseMode)) return false;
            return info?.infix;
        }
        return false;
    }
    matchColumnSeparator(): boolean {
        const index = this.index;
        if (this.tabularMode && this.tokens[index] === '&') {
            this.index++;
            return true;
        }
        return false;
    }
    matchRowSeparator(): boolean {
        const index = this.index;
        if (
            this.tabularMode &&
            (this.tokens[index] === '\\\\' || this.tokens[index] === '\\cr')
        ) {
            this.index++;
            return true;
        }
        return false;
    }
    /**
     * Return the appropriate value for a placeholder, either a default
     * one, or if a value was provided for #? via args, that value.
     */
    placeholder(): Atom[] {
        if (!this.args || typeof this.args['?'] === 'undefined') {
            // U+2753 = BLACK QUESTION MARK ORNAMENT
            const result = new Atom(
                this.parseMode,
                'placeholder',
                '?',
                this.style
            );
            result.captureSelection = true;
            return [result];
        }
        if (typeof this.args?.['?'] === 'string') {
            // If there is a specific value defined for the placeholder,
            // use it.
            return parseString(
                this.args['?'],
                this.parseMode,
                null,
                this.macros,
                false,
                this.onError
            );
        }
        return this.args['?'];
    }

    // matchToken(type: string): boolean {
    //     if (this.hasToken(type)) {
    //         this.index++;
    //         return true;
    //     }
    //     return false;
    // }
    matchWhitespace(): boolean {
        let found = false;
        while (this.match('<space>')) {
            found = true;
        }
        return found;
    }
    skipUntilToken(input: string): void {
        let token = this.tokens[this.index];
        while (token && token !== input) {
            token = this.tokens[++this.index];
        }
        if (token === input) {
            this.index++;
        }
    }

    skipFiller(): void {
        let done = false;
        do {
            const skippedSpace = this.matchWhitespace();
            const skippedRelax = this.match('\\relax');
            done = !skippedSpace && !skippedRelax;
        } while (!done);
    }
    /**
     * Keywords are used to specify dimensions, and for various other
     * syntactic constructs.
     *
     * Unlike commands, they are not case sensitive.
     *
     * There are 25 keywords:
     *
     * at by bp cc cm dd depth em ex fil fill filll height in minus
     * mm mu pc plus pt sp spread to true width
     *
     * TeX: 8212
     * @return true if the expected keyword is present
     */
    matchKeyword(keyword: string): boolean {
        const savedIndex = this.index;
        let done = this.end();
        let value = '';
        while (!done) {
            const token = this.get();
            if (isLiteral(token)) {
                value += token;
                done = this.end() || value.length >= keyword.length;
            } else {
                done = true;
            }
        }
        const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
        if (!hasKeyword) {
            this.index = savedIndex;
        }
        return hasKeyword;
    }
    /**
     * Return a sequence of characters as a string.
     * i.e. 'abcd' returns 'abcd'.
     * Terminates on the first non-literal token encountered
     * e.g. '<{>', '<}>' etc...
     * Will also terminate on character literal ']'
     */
    scanString(): string {
        let result = '';
        let done = this.end();
        while (!done) {
            if (this.match('<space>')) {
                result += ' ';
            } else {
                const token = this.peek();
                if (token === ']') {
                    done = true;
                } else if (isLiteral(token)) {
                    result += this.get();
                } else if (token[0] === '\\') {
                    // TeX will give a 'Missing \endcsname inserted' error
                    // if it encounters any command when expecting a string.
                    // We're a bit more lax.
                    this.onError({ code: 'unbalanced-braces' });
                    result += this.get();
                } else {
                    // It's '<{>', '<}>', '<$>' or '<$$>
                    done = true;
                }
            }
            done = done || this.end();
        }
        return result;
    }
    /**
     * Return a sequence of characters as a string.
     * Terminates on a balanced closing bracket
     * This is used by the `\ce` command
     */
    scanBalancedString(): string {
        let result = '';
        let done = this.end();
        let level = 1;
        while (!done) {
            if (this.match('<space>')) {
                result += ' ';
            } else {
                const token = this.get();
                if (token === '<{>') {
                    result += '{';
                    level += 1;
                } else if (token === '<}>') {
                    level -= 1;
                    if (level > 0) {
                        result += '}';
                    } else {
                        this.index -= 1;
                    }
                } else if (token === '<$>') {
                    result += '$';
                } else if (token === '<$$>') {
                    result += '$$';
                } else {
                    result += token;
                }
            }
            done = level === 0 || this.end();
        }
        return result;
    }
    /**
     * Return the literal tokens, as a string, until a matching closing "}"
     */
    matchLiteralArg(): string {
        let result = '';
        if (this.match('<{>')) {
            let depth = 1;
            while (depth > 0 && !this.end()) {
                const token = this.get()!;
                if (token === '<}>') {
                    depth -= 1;
                    if (depth > 0) {
                        // Don't include final '}'
                        result += '}';
                    }
                } else if (token === '<{>') {
                    depth += 1;
                    result += '{';
                } else {
                    result +=
                        {
                            '<space>': ' ',
                            '<$$>': '$$',
                            '<$>': '$',
                        }[token] ?? token;
                }
            }
        }
        return result;
    }
    /**
     * Return a CSS color (#rrggbb)
     */
    scanColor(): string {
        return stringToColor(this.scanString());
    }
    /**
     * Return as a number a group of characters representing a
     * numerical quantity.
     *
     * From TeX:8695 (scan_int):
     * An integer number can be preceded by any number of spaces and `+' or
     * `-' signs. Then comes either a decimal constant (i.e., radix 10), an
     * octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
     * (radix 16, preceded by "), an alphabetic constant (preceded by `), or
     * an internal variable.
     */
    scanNumber(isInteger = true): number {
        let negative = false;
        let token = this.peek();
        while (token === '<space>' || token === '+' || token === '-') {
            this.get();
            if (token === '-') negative = !negative;
            token = this.peek();
        }

        isInteger = Boolean(isInteger);

        let radix = 10;
        let digits = /[0-9]/;
        if (this.match("'")) {
            // Apostrophe indicates an octal value
            radix = 8;
            digits = /[0-7]/;
            isInteger = true;
        } else if (this.match('"') || this.match('x')) {
            // Double-quote indicates a hex value
            // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
            // For example: 'x3a'
            radix = 16;
            // Hex digits have to be upper-case
            digits = /[0-9A-F]/;
            isInteger = true;
        } else if (this.match('`')) {
            // A backtick indicates an alphabetic constant: a letter, or a single-letter command
            token = this.get();
            if (token) {
                if (token.startsWith('\\') && token.length === 2) {
                    return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
                }
                return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
            }
            return NaN;
        }
        let value = '';
        while (this.hasPattern(digits)) {
            value += this.get();
        }
        // Parse the fractional part, if applicable
        if (!isInteger && (this.match('.') || this.match(','))) {
            value += '.';
            while (this.hasPattern(digits)) {
                value += this.get();
            }
        }
        const result = isInteger ? parseInt(value, radix) : parseFloat(value);
        return negative ? -result : result;
    }
    /**
     * Return as a floating point number a dimension in pt (1 em = 10 pt)
     *
     * See TeX:8831
     * @todo: note that some units depend on the font (em, ex). So it might be
     * better to return a dimen struct with the value + unit and resolve
     * later when we have a font context....
     */
    scanDimen(): number {
        const value = this.scanNumber(false);
        this.matchWhitespace();
        let result: number;
        if (this.matchKeyword('pt')) {
            result = convertDimenToEm(value, 'pt');
        } else if (this.matchKeyword('mm')) {
            result = convertDimenToEm(value, 'mm');
        } else if (this.matchKeyword('cm')) {
            result = convertDimenToEm(value, 'cm');
        } else if (this.matchKeyword('ex')) {
            result = convertDimenToEm(value, 'ex');
        } else if (this.matchKeyword('px')) {
            result = convertDimenToEm(value, 'px');
        } else if (this.matchKeyword('em')) {
            result = convertDimenToEm(value, 'em');
        } else if (this.matchKeyword('bp')) {
            result = convertDimenToEm(value, 'bp');
        } else if (this.matchKeyword('dd')) {
            result = convertDimenToEm(value, 'dd');
        } else if (this.matchKeyword('pc')) {
            result = convertDimenToEm(value, 'pc');
        } else if (this.matchKeyword('in')) {
            result = convertDimenToEm(value, 'in');
        } else if (this.matchKeyword('mu')) {
            result = convertDimenToEm(value, 'mu');
        } else {
            // If the units are missing, TeX assumes 'pt'
            this.onError({ code: 'missing-unit' });
            result = convertDimenToEm(value, 'pt');
        }
        return result;
    }
    scanSkip(): number {
        const result = this.scanDimen();
        // We parse, but ignore, the optional 'plus' and 'minus'
        // arguments.
        this.matchWhitespace();
        // 'plus', optionally followed by 'minus'
        // ('minus' cannot come before 'plus')
        // dimen or 'hfill'
        if (this.matchKeyword('plus')) {
            // @todo there could also be a \hFilLlL command here
            this.scanDimen();
        }
        this.matchWhitespace();
        if (this.matchKeyword('minus')) {
            // @todo there could also be a \hFilLlL command here
            this.scanDimen();
        }
        return result;
    }
    scanColspec(): Colspec[] {
        this.matchWhitespace();
        const result: Colspec[] = [];
        while (!this.end() && !(this.peek() === '<}>' || this.peek() === ']')) {
            const literal = this.get();
            if (literal === 'c' || literal === 'r' || literal === 'l') {
                result.push({ align: literal });
            } else if (literal === '|') {
                result.push({ rule: true });
            } else if (literal === '@') {
                if (this.match('<{>')) {
                    const savedParsemode = this.swapParseMode('math');
                    result.push({
                        gap: this.parse((token) => token === '<}>'),
                    });
                    this.swapParseMode(savedParsemode);
                }
                if (!this.match('<}>')) {
                    this.onError({ code: 'unbalanced-braces' });
                }
            }
        }
        return result;
    }
    /**
     * Parse a `\(...\)` or `\[...\]` sequence
     * @return group for the sequence or null
     */
    parseModeSet(): Atom | null {
        let final: Token = '';
        if (this.match('\\(')) final = '\\)';
        if (!final && this.match('\\[')) final = '\\]';
        if (!final) return null;
        const savedParsemode = this.swapParseMode('math');
        const result = new Atom('math', 'group');
        result.mathstyle = final === '\\)' ? 'textstyle' : 'displaystyle';
        result.body = this.parse((token) => token === final);
        if (!this.match(final)) {
            this.onError({ code: 'unbalanced-mode-shift' });
        }
        this.swapParseMode(savedParsemode);
        if (!result.body || result.body.length === 0) return null;
        return result;
    }
    /**
     * Parse a `$...$` or `$$...$$` sequence
     */
    parseModeShift(): Atom | null {
        let final: Token = '';
        if (this.match('<$>')) final = '<$>';
        if (!final && this.match('<$$>')) final = '<$$>';
        if (!final) return null;

        const result = new Atom('math', 'group');
        result.mathstyle = final === '<$>' ? 'textstyle' : 'displaystyle';
        result.latexOpen = final === '<$>' ? '$' : '$$';
        result.latexClose = result.latexOpen;
        const savedParsemode = this.swapParseMode('math');
        result.body = this.parse((token: Token) => token === final);
        if (!this.match(final)) {
            this.onError({ code: 'unbalanced-mode-shift' });
        }
        this.swapParseMode(savedParsemode);
        if (!result.body || result.body.length === 0) return null;
        return result;
    }
    /**
     * Parse a \begin{env}...\end{end} sequence
     */
    parseEnvironment(): Atom | null {
        // An environment starts with a \begin command
        if (!this.match('\\begin')) return null;

        // The \begin command is immediately followed by the environment
        // name, as a string argument
        const envName = this.parseArgument('string') as string;
        if (!envName) return null;
        const def = getEnvironmentDefinition(envName);
        if (!def) {
            this.onError({
                code: 'unknown-environment',
                arg: envName,
            });
            return null;
        }

        // If the environment has some arguments, parse them
        const args: (string | number | BBoxParam | Colspec[] | Atom[])[] = [];
        if (def?.params) {
            for (const param of def.params) {
                // Parse an argument
                if (param.isOptional) {
                    // If it's not present, scanArg returns null,
                    // but push it on the list of arguments anyway.
                    // The null value will be interpreted as unspecified
                    // optional value by the command parse function.
                    args.push(this.parseOptionalArgument(param.type));
                } else {
                    const arg:
                        | string
                        | number
                        | BBoxParam
                        | Colspec[]
                        | Atom[] = this.parseArgument(param.type);
                    if (!arg) {
                        this.onError({
                            code: 'missing-argument',
                            arg: envName,
                        });
                    }
                    args.push(arg);
                }
            }
        }
        // Some environments change the mode
        const savedMode = this.parseMode;
        const savedTabularMode = this.tabularMode;
        const saveAtoms = this.swapAtoms([]);
        // @todo: since calling scanImplicitGroup(), may not need to save/restore the atoms
        this.tabularMode = def.tabular;
        const array: Atom[][][] = [];
        const rowGaps: number[] = [];
        let row: Atom[][] = [];
        let done = false;
        do {
            if (this.end()) {
                this.onError({ code: 'unbalanced-environment', arg: envName });
                done = true;
            }
            if (!done && this.match('\\end')) {
                if (this.parseArgument('string') !== envName) {
                    this.onError({
                        code: 'unbalanced-environment',
                        arg: envName,
                    });
                }
                done = true;
            }
            if (!done) {
                if (this.matchColumnSeparator()) {
                    row.push(this.swapAtoms([]));
                } else if (this.matchRowSeparator()) {
                    row.push(this.swapAtoms([]));
                    let gap = 0;
                    this.matchWhitespace();
                    if (this.match('[')) {
                        gap = this.scanDimen();
                        this.matchWhitespace();
                        this.match(']');
                    }
                    rowGaps.push(gap || 0);
                    array.push(row);
                    row = [];
                } else {
                    this.atoms = this.atoms.concat(
                        this.parse(
                            (token: Token) =>
                                token === '<}>' ||
                                token === '&' ||
                                token === '\\end' ||
                                token === '\\cr' ||
                                token === '\\\\'
                        )
                    );
                }
            }
        } while (!done);
        row.push(this.swapAtoms([]));
        if (row.length > 0) array.push(row);
        const newAtoms = this.swapAtoms(saveAtoms);
        // If we're in tabular mode, we should end up with an empty atoms list
        console.assert(
            !this.tabularMode || newAtoms.length === 0,
            'Leftover atoms in tabular mode'
        );
        this.parseMode = savedMode;
        this.tabularMode = savedTabularMode;

        if (!def.tabular && newAtoms.length === 0) return null;
        if (def.tabular && array.length === 0) return null;

        const result = new Atom(this.parseMode, 'array', newAtoms);
        Object.assign(result, def.parser(envName, args, array));
        result.array = array;
        result.rowGaps = rowGaps;
        result.environmentName = envName;
        return result;
    }
    /**
     * Parse a sequence until a group end marker, such as
     * `}`, `\end`, `&`, etc...
     *
     * Returns an array of atoms or an empty array if the sequence
     * terminates right away.
     *
     * @param done - A predicate indicating if a
     * token signals the end of an implicit group
     */
    parse(done?: (token: Token) => boolean): Atom[] {
        const savedStyle = this.style;
        if (!done) {
            // Default group end marker
            done = (token: Token): boolean => token === '<}>';
        }
        // To handle infix commands, we'll keep track of their prefix
        // (tokens coming before them) and their arguments
        let infix: Token = '';
        let infixInfo: (FunctionDefinition & SymbolDefinition) | null = null;
        let infixArgs: Atom[][] = [];
        let prefix: Atom[] | null = null;
        const saveAtoms = this.swapAtoms([]);
        while (!this.end() && !done(this.peek())) {
            if (this.hasInfixCommand() && !infix) {
                // The next token is an infix and we have not seen one yet
                // (there can be only one infix command per implicit group).
                infix = this.get();
                // The current parseMode, this.parseMode, may no longer have the value
                // it had when we encountered the infix. However, since all infix are
                // only defined in 'math' mode, we can use the 'math' constant
                // for the parseMode
                infixInfo = getInfo(infix, 'math', this.macros);
                if (infixInfo) {
                    infixArgs = this.parseArguments(infixInfo)[1] as Atom[][];
                }
                // Save the math list so far and start a new one
                prefix = this.swapAtoms([]);
            } else {
                this.parseToken();
            }
        }
        let result: Atom[];
        if (infix) {
            console.assert(Boolean(infixInfo));
            infixArgs.unshift(this.swapAtoms(saveAtoms)); // suffix
            if (prefix) infixArgs.unshift(prefix);
            result = [
                new Atom(
                    this.parseMode,
                    infixInfo!.type,
                    infixInfo!.value ?? infix.slice(1), // Functions don't have
                    infixInfo!.parse ? infixInfo!.parse(infix, infixArgs) : null
                ),
            ];
            result[0].symbol = infix;
        } else {
            result = this.swapAtoms(saveAtoms);
        }

        this.style = savedStyle;

        return result;
    }
    /**
     * Parse a group enclosed in a pair of braces: `{...}`.
     *
     * Return either a group Atom or null if not a group.
     *
     * Return a group Atom with an empty body if an empty
     * group (i.e. `{}`).
     */
    parseGroup(): Atom | null {
        if (!this.match('<{>')) return null;
        const result = new Atom(this.parseMode, 'group');
        result.body = this.parse((token: Token) => token === '<}>');
        if (!this.match('<}>')) {
            this.onError({ code: 'unbalanced-braces' });
        }
        result.latexOpen = '{';
        result.latexClose = '}';
        return result;
    }
    scanSmartFence(): Atom | null {
        this.matchWhitespace();
        if (!this.match('(')) return null;
        // We've found an open paren... Convert to a `\mleft...\mright`
        const result = new Atom(this.parseMode, 'leftright');
        result.leftDelim = '(';
        result.inner = false; // It's a `\mleft`, not a `\left`
        const saveAtoms = this.swapAtoms([]);
        let nestLevel = 1;
        while (!this.end() && nestLevel !== 0) {
            if (this.match('(')) nestLevel += 1;
            if (this.match(')')) nestLevel -= 1;
            if (nestLevel !== 0) this.parseToken();
        }
        if (nestLevel === 0) this.match(')');
        result.rightDelim = nestLevel === 0 ? ')' : '?';
        result.body = this.swapAtoms(saveAtoms);
        return result;
    }
    /**
     * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
     *
     * @return The delimiter (as a character or command) or null
     */
    scanDelim(): string | null {
        this.matchWhitespace();
        const token = this.get();
        if (!token) {
            this.onError({ code: 'unexpected-end-of-string' });
            return null;
        }
        let delim = '.';
        if (token[0] === '\\' || isLiteral(token)) {
            delim = token;
        }
        const info = getInfo(delim, 'math', this.macros);
        if (!info) {
            this.onError({ code: 'unknown-command', arg: delim });
            return null;
        }
        if (info.mode && !info.mode.includes(this.parseMode)) {
            this.onError({ code: 'unexpected-delimiter', arg: delim });
            return null;
        }
        if (info.type === 'mopen' || info.type === 'mclose') {
            return delim;
        }
        // Some symbols are not of type mopen/mclose, but are still
        // valid delimiters...
        // '?' is a special delimiter used as a 'placeholder'
        // (when the closing delimiter is displayed greyed out)
        if (
            /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
                delim
            )
        ) {
            return delim;
        }
        this.onError({ code: 'unexpected-delimiter', arg: delim });
        return null;
    }
    /**
     * Parse a `/left.../right` sequence.
     *
     * Note: the `/middle` command can occur multiple times inside a
     * `/left.../right` sequence, and is handled separately.
     *
     * Return either an atom of type `'leftright'` or null
     */
    parseLeftRight(): Atom | null {
        if (this.match('\\right') || this.match('\\mright')) {
            // We have an unbalanced left/right (there's a \right, but no \left)
            this.onError({ code: 'unbalanced-braces' });
            return null;
        }

        const savedStyle = this.style;

        let close = '\\right';
        if (!this.match('\\left')) {
            if (!this.match('\\mleft')) return null;
            close = '\\mright';
        }
        const leftDelim = this.scanDelim();
        if (!leftDelim) return null;

        const saveAtoms = this.swapAtoms([]);
        while (!this.end() && !this.match(close)) {
            this.parseToken();
        }
        this.style = savedStyle;

        // If we've reached the end and there was no `\right` or
        // there isn't a valid delimiter after `\right`, we'll
        // consider the `\right` missing and set the `rightDelim` to undefined
        const rightDelim = this.scanDelim();

        const result = new Atom(this.parseMode, 'leftright');
        result.leftDelim = leftDelim;
        result.rightDelim = rightDelim ?? undefined;
        result.inner = close === 'right';
        result.body = this.swapAtoms(saveAtoms);
        return result;
    }
    /**
     * Parse a subscript/superscript: `^` and `_`.
     *
     * Modify the last atom accordingly.
     *
     */
    parseSupSub(): boolean {
        // No sup/sub in text or command mode.
        if (this.parseMode !== 'math') return false;
        // Apply the subscript/superscript to the last rendered atom.
        // If none is present (beginning of the list, i.e. `{^2}`,
        // an empty atom will be created, equivalent to `{{}^2}`
        let result = false;
        let token = this.peek();
        while (token === '^' || token === '_' || token === "'") {
            const supsub = token === '_' ? 'subscript' : 'superscript';
            if (this.match('^') || this.match('_')) {
                const arg = this.parseArgument('math');
                if (arg) {
                    const atom = this.lastSubsupAtom();
                    atom[supsub] = (atom[supsub] ?? []).concat(arg as Atom[]);
                    result = true;
                }
            } else if (this.match("'")) {
                // A single quote (prime) is actually equivalent to a
                // '^{\prime}'
                const base = this.lastSubsupAtom();
                const atom = new Atom(base.mode, 'mord', '\u2032');
                atom.symbol = '\\prime';
                base.superscript = base.superscript ?? [];
                base.superscript.push(atom);
                result = true;
            }
            token = this.peek();
        }
        return result;
    }
    /**
     * Parse a `\limits` or `\nolimits` command.
     *
     * This will change the placement of limits to be either above or below
     * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
     *
     * This overrides the calculation made for the placement, which is usually
     * dependent on the displaystyle (`inlinemath` prefers `\nolimits`, while
     * `displaymath` prefers `\limits`).
     */
    parseLimits(): boolean {
        // Note: technically, \limits and \nolimits are only applicable
        // after an operator. However, we apply them in all cases. They
        // will simply be ignored when not applicable (i.e. on a literal)
        // which is actually consistent with TeX.
        if (this.match('\\limits')) {
            const lastAtom = this.lastSubsupAtom();
            lastAtom.limits = 'limits';
            // Record that the limits was set through an explicit command
            // so we can generate the appropriate LaTeX later
            lastAtom.explicitLimits = true;
            return true;
        }
        if (this.match('\\nolimits')) {
            const lastAtom = this.lastSubsupAtom();
            lastAtom.limits = 'nolimits';
            // Record that the limits was set through an explicit command
            // so we can generate the appropriate LaTeX later
            lastAtom.explicitLimits = true;
            return true;
        }
        return false;
    }
    parseArguments(
        info: FunctionDefinition
    ): [
        ParseModePrivate,
        (string | number | BBoxParam | Colspec[] | Atom[])[]
    ] {
        if (!info || !info.params) return [undefined, []];
        let explicitGroup: ParseModePrivate;
        const args: (string | number | BBoxParam | Colspec[] | Atom[])[] = [];
        let i = info.infix ? 2 : 0;
        while (i < info.params.length) {
            const param = info.params[i];
            // Parse an argument
            if (param.isOptional) {
                args.push(this.parseOptionalArgument(param.type));
            } else if (param.type.endsWith('*')) {
                // For example 'math*'.
                // In this case, indicate that a 'yet-to-be-parsed'
                // argument (and 'explicit group') is present
                explicitGroup = param.type.slice(0, -1) as ParseModePrivate;
            } else {
                const arg = this.parseArgument(param.type);
                if (typeof arg !== 'undefined') {
                    args.push(arg);
                } else {
                    // Report an error
                    this.onError({ code: 'missing-argument' });
                    args.push(this.placeholder());
                }
            }
            i += 1;
        }
        return [explicitGroup, args];
    }
    /**
     * Parse a math field, an argument to a function.
     *
     * An argument can either be a single atom or
     * a sequence of atoms enclosed in braces.
     *
     * @param parseMode Temporarily overrides the parser parsemode. For
     * example: `'dimen'`, `'color'`, `'text'`, etc...
     */
    // parseArgument(parseMode: 'string'): string;
    // parseArgument(parseMode: 'color'): string;
    parseArgument(
        parseMode: ParseModePrivate
    ): string | number | Atom[] | Colspec[] {
        this.skipFiller();
        parseMode = parseMode === 'auto' ? this.parseMode : parseMode;
        let result: string | number | Atom[] | Colspec[];
        // An argument (which is called a 'math field' in TeX)
        // could be a single character or symbol, as in `\frac12`
        // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
        // ``\frac{\sqrt}{-1}{\beta}``
        if (!this.match('<{>')) {
            if (parseMode === 'delim') {
                return this.scanDelim() ?? '.';
            } else if (/^(math|text)$/.test(parseMode)) {
                // Parse a single token.
                const savedParseMode = this.swapParseMode(parseMode);
                const atom = this.parseSimpleToken();
                this.swapParseMode(savedParseMode);
                return atom;
            }
        }

        const savedParseMode = this.parseMode;
        this.parseMode = parseMode;
        const saveAtoms = this.swapAtoms([]);
        if (parseMode === 'string') {
            result = this.scanString();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'balanced-string') {
            result = this.scanBalancedString();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'number') {
            result = this.scanNumber();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'dimen') {
            result = this.scanDimen();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'skip') {
            result = this.scanSkip();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'colspec') {
            result = this.scanColspec();
            this.skipUntilToken('<}>');
        } else if (parseMode === 'color') {
            result = this.scanColor() || '#ffffff';
            this.skipUntilToken('<}>');
        } else if (parseMode === 'delim') {
            result = this.scanDelim() || '.';
            this.skipUntilToken('<}>');
        } else {
            console.assert(
                /^(math|text)$/.test(parseMode),
                'Unexpected parse mode: "' + parseMode + '"'
            );

            // Collect an array of tokens until a balanced "}"
            const initialIndex = this.index;
            let depth = 1;
            do {
                const token = this.get();
                if (token === '<}>') depth -= 1;
                if (token === '<{>') depth += 1;
            } while (depth > 0 && !this.end());
            result = parseTokens(
                parseMode,
                this.tokens.slice(initialIndex, this.index - 1),
                this.onError,
                {
                    args: this.args,
                    macros: this.macros,
                    smartFence: this.smartFence,
                    style: this.style,
                    parse: (
                        mode: ParseModePrivate,
                        tokens: Token[],
                        options
                    ): [Atom[], Token[]] => {
                        const parser = new Parser(
                            tokens,
                            options.args,
                            options.macros,
                            this.onError
                        );
                        parser.parseMode = mode;
                        parser.style = options.style;
                        result = parser.parse();
                        return [result, tokens.slice(parser.index)];
                    },
                }
            );
            if (!result) {
                // No mode-specific result. Try again from the start
                this.index = initialIndex;
                do {
                    this.atoms = this.atoms.concat(this.parse());
                } while (!this.match('<}>') && !this.end());
            }
        }
        this.parseMode = savedParseMode;
        const atoms = this.swapAtoms(saveAtoms);
        return result ?? atoms;
    }
    parseOptionalArgument(
        parseMode: ParseModePrivate
    ): string | number | BBoxParam | Colspec[] | Atom[] {
        parseMode = parseMode === 'auto' ? this.parseMode : parseMode;
        this.matchWhitespace();
        if (!this.match('[')) return null;
        const savedParseMode = this.parseMode;
        this.parseMode = parseMode;
        const saveAtoms = this.swapAtoms();
        let result: string | number | BBoxParam | Colspec[] | Atom[];
        while (!this.end() && !this.match(']')) {
            if (parseMode === 'string') {
                result = this.scanString();
            } else if (parseMode === 'number') {
                result = this.scanNumber();
            } else if (parseMode === 'dimen') {
                result = this.scanDimen();
            } else if (parseMode === 'skip') {
                result = this.scanSkip();
            } else if (parseMode === 'colspec') {
                result = this.scanColspec();
            } else if (parseMode === 'color') {
                result = this.scanColor() ?? '#ffffff';
            } else if (parseMode === 'bbox') {
                // The \bbox command takes a very particular argument:
                // a comma delimited list of up to three arguments:
                // a color, a dimension and a string.
                // Split the string by comma delimited sub-strings, ignoring commas
                // that may be inside (). For example"x, rgb(a, b, c)" would return
                // ['x', 'rgb(a, b, c)']
                const list = this.scanString()
                    .toLowerCase()
                    .trim()
                    .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
                const bboxParam: BBoxParam = {};
                for (const elem of list) {
                    const color = stringToColor(elem);
                    if (color) {
                        bboxParam.backgroundcolor = color;
                    } else {
                        const m = elem.match(/^\s*([0-9.]+)\s*([a-z][a-z])/);
                        if (m) {
                            bboxParam.padding = convertDimenToEm(m[1], m[2]);
                        } else {
                            const m = elem.match(/^\s*border\s*:\s*(.*)/);
                            if (m) {
                                bboxParam.border = m[1];
                            }
                        }
                    }
                }
                result = bboxParam;
            } else {
                console.assert(
                    parseMode === 'math',
                    'Unexpected parse mode: "' + parseMode + '"'
                );
                this.atoms = this.atoms.concat(
                    this.parse((token) => token === ']')
                );
            }
        }
        this.parseMode = savedParseMode;
        const atoms = this.swapAtoms(saveAtoms);
        return result ?? atoms;
    }

    parseSimpleToken(): Atom[] {
        const token = this.get();
        if (!token) return null;
        let result: Atom | Atom[] | null = null;
        if (token === '<space>') {
            if (this.parseMode === 'text') {
                result = new Atom('text', '', ' ', this.style);
                result.symbol = ' ';
            }
        } else if (token[0] === '\\') {
            // COMMAND
            if (token === '\\placeholder') {
                result = new Atom(
                    this.parseMode,
                    'placeholder',
                    this.parseArgument('string') as string,
                    this.style
                );
                result.captureSelection = true;
            } else if (token === '\\char') {
                // \char has a special syntax and requires a non-braced integer
                // argument
                const initialIndex = this.index;
                let codepoint = Math.floor(this.scanNumber(true));
                if (
                    !isFinite(codepoint) ||
                    codepoint < 0 ||
                    codepoint > 0x10ffff
                ) {
                    codepoint = 0x2753; // BLACK QUESTION MARK
                }
                result = new Atom(
                    this.parseMode,
                    this.parseMode === 'math' ? 'mord' : '',
                    String.fromCodePoint(codepoint)
                );
                result.symbol = '\\char';
                result.latex =
                    '\\char' +
                    tokensToString(this.tokens.slice(initialIndex, this.index));
            } else if (token === '\\hskip' || token === '\\kern') {
                // \hskip and \kern have a special syntax and requires a non-braced
                // 'skip' argument
                const width = this.scanSkip();
                if (isFinite(width)) {
                    result = new Atom(
                        this.parseMode,
                        'spacing',
                        null,
                        this.style
                    );
                    result.width = width;
                    result.symbol = token;
                    result.latex = token;
                }
            } else {
                result = this.scanMacro(token);
                if (!result) {
                    // This wasn't a macro, so let's see if it's a regular command
                    const info = getInfo(token, this.parseMode, {});

                    if (!info) {
                        // An unknown command
                        this.onError({
                            code: 'unknown-command',
                            arg: token,
                        });
                        result = new Atom('math', 'error', token);
                        result.symbol = token;
                        result.latex = token;
                        return [result];
                    }

                    if (info.mode && !info.mode.includes(this.parseMode)) {
                        // Command invalid in this mode
                        this.onError({
                            code: 'invalid-command',
                            arg: token,
                        });
                        result = new Atom('math', 'error', token);
                        result.symbol = token;
                        result.latex = token;
                        return [result];
                    }

                    // Parse the arguments
                    // If explicitGroup is not empty, an explicit group is expected
                    // to follow the command and will be parsed *after* the
                    // command has been processed.
                    // This is used for commands such as \textcolor{color}{content}
                    // that need to apply the color to the content *after* the
                    // style has been changed.
                    // In definitions, this is indicated with a parameter type
                    // of 'auto*'
                    const initialIndex = this.index;
                    const [explicitGroup, args] = this.parseArguments(info);

                    if (!args) return null; // Some required arguments were missing...

                    if (info.infix) {
                        // Infix commands should be handled in scanImplicitGroup
                        // If we find an infix command here, it's a syntax error
                        // (second infix command in a group) and should be ignored.
                        this.onError({
                            code: 'too-many-infix-commands',
                            arg: token,
                        });
                    } else {
                        //  Invoke the parse() function if present
                        if (info.parse) {
                            const attributes = info.parse(token, args);
                            if (attributes.type) {
                                // A type was provided: create a new Atom
                                result = new Atom(
                                    this.parseMode,
                                    info.type,
                                    explicitGroup
                                        ? (this.parseArgument(
                                              explicitGroup
                                          ) as Atom[])
                                        : null,
                                    { ...this.style, ...attributes }
                                );
                            } else {
                                // No type provided -> the parse function will modify
                                // the current style rather than create a new Atom.
                                const savedMode = this.parseMode;
                                if (attributes.mode) {
                                    // Change to 'text' (or 'math') mode if necessary
                                    this.parseMode = attributes.mode;
                                    delete attributes.mode;
                                }
                                if (attributes.mathstyle) {
                                    this.parseMode = 'math';
                                    const atom = new Atom('math', 'mathstyle');
                                    atom.mathstyle = attributes.mathstyle;
                                    this.atoms.push(atom);
                                }

                                // If an explicit group is expected, process it now
                                if (explicitGroup) {
                                    // Create a temporary style
                                    const saveStyle = this.style;
                                    this.style = {
                                        ...this.style,
                                        ...attributes,
                                    };
                                    result = this.parseArgument(
                                        explicitGroup
                                    ) as Atom[];
                                    this.style = saveStyle;
                                } else {
                                    // Merge the new style info with the current style
                                    this.style = {
                                        ...this.style,
                                        ...attributes,
                                    };
                                }
                                this.parseMode = savedMode;
                            }
                        } else {
                            // The new atom will inherit the style of this atom
                            // Only override the variant if it is not '' or undefined
                            const style = {
                                ...this.style,
                                variant: info.variant || this.style.variant,
                                variantStyle:
                                    info.variantStyle ||
                                    this.style.variantStyle,
                            };
                            result = new Atom(
                                this.parseMode,
                                info.type || 'mop',
                                info.value || token,
                                style
                            );
                        }
                        if (
                            result instanceof Atom &&
                            !/^\\(llap|rlap|class|cssId)$/.test(token)
                        ) {
                            result.symbol = token;
                            const argString = tokensToString(
                                this.tokens.slice(initialIndex, this.index)
                            );
                            if (argString) {
                                result.latex = result.symbol + argString;
                            }
                            if (result.isFunction && this.smartFence) {
                                // The atom was a function that may be followed by
                                // an argument, like `\sin(`
                                const smartFence = this.scanSmartFence();
                                if (smartFence) {
                                    result = [result, smartFence];
                                }
                            }
                        }
                    }
                }
            }
        } else if (isLiteral(token)) {
            // Literal
            const info = getInfo(token, this.parseMode, this.macros);
            if (info) {
                const style = { ...this.style };
                result = new Atom(
                    this.parseMode,
                    info.type,
                    info.value || token,
                    style
                );
                if (info.isFunction) {
                    result.isFunction = true;
                }
            } else {
                result = new Atom(
                    this.parseMode,
                    this.parseMode === 'math' ? 'mord' : '',
                    token,
                    this.style
                );
            }
            result.symbol = token;
            result.latex = unicodeCharToLatex(this.parseMode, token);
            if (info?.isFunction && this.smartFence) {
                // The atom was a function that may be followed by
                // an argument, like `f(`.
                const smartFence = this.scanSmartFence();
                if (smartFence) {
                    result = [result, smartFence];
                }
            }
        } else if (token === '<}>') {
            this.onError({ latex: '', code: 'unbalanced-braces' });
        } else {
            this.onError({
                latex: '',
                code: 'unexpected-token',
                arg: token,
            });
        }
        // Always return an array of atoms
        return result && !isArray(result)
            ? [result as Atom]
            : (result as Atom[]);
    }
    /**
     * Attempt to scan the macro name and return an atom list if successful.
     * Otherwise, it wasn't a macro.
     */
    scanMacro(macro: string): Atom {
        const macroName = macro.slice(1);
        if (!this.macros || !this.macros[macroName]) return null;
        const initialIndex = this.index;
        const args: (string | Atom[])[] = [];
        let def: string;
        let argCount = 0;
        if (typeof this.macros[macroName] === 'string') {
            def = this.macros[macroName] as string;
            // Let's see if there are arguments in the definition.
            if (/(^|[^\\])#1/.test(def)) argCount = 1;
            if (/(^|[^\\])#2/.test(def)) argCount = 2;
            if (/(^|[^\\])#3/.test(def)) argCount = 3;
            if (/(^|[^\\])#4/.test(def)) argCount = 4;
            if (/(^|[^\\])#5/.test(def)) argCount = 5;
            if (/(^|[^\\])#6/.test(def)) argCount = 6;
            if (/(^|[^\\])#7/.test(def)) argCount = 7;
            if (/(^|[^\\])#8/.test(def)) argCount = 8;
            if (/(^|[^\\])#9/.test(def)) argCount = 9;
        } else {
            def = (this.macros[macroName] as MacroDefinition).def;
            argCount = (this.macros[macroName] as MacroDefinition).args || 0;
        }
        for (let i = 1; i <= argCount; i++) {
            // Parse each argument as a string. We don't know yet
            // what the proper parse mode is, so defer parsing till later
            // when invoking `parseString`
            args[i] = this.matchLiteralArg();
        }
        // Carry forward the placeholder argument, if any.
        args['?'] = this.args?.['?'];

        // Group the result of the macro expansion, and set the
        // captureSelection attribute so that it is handled as an unbreakable
        // unit
        const atom = new Atom(
            this.parseMode,
            'group',
            parseString(
                def,
                this.parseMode,
                args,
                this.macros,
                false,
                this.onError
            )
        );
        atom.captureSelection = true;
        atom.symbol = macro;
        atom.latex =
            macro + tokensToString(this.tokens.slice(initialIndex, this.index));
        return atom;
    }
    /**
     * Make an atom for the current token or token group and
     * add it to the parser's current atoms
     */
    parseToken(): boolean {
        let result: Atom | Atom[] =
            this.parseEnvironment() ||
            this.parseModeShift() ||
            this.parseModeSet() ||
            this.parseGroup() ||
            this.parseLeftRight();
        if (!result && (this.parseSupSub() || this.parseLimits())) return true;
        if (!result) result = this.parseSimpleToken();
        // If we have an atom to add, push it at the end of the current math list
        // We could have no atom for tokens that were skipped, a ' ' in math mode
        // for example
        if (isArray(result)) {
            this.atoms = this.atoms.concat(result);
        } else if (result) {
            this.atoms.push(result);
        }
        return result !== null;
    }
}

/**
 * Given a string of LaTeX, return a corresponding math list (array of atoms).
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
export function parseString(
    s: string,
    parseMode: ParseModePrivate,
    args: null | (string | Atom[])[],
    macros: null | MacroDictionary,
    smartFence = false,
    onError?: ErrorListener<ParserErrorCode>
): Atom[] {
    let atoms = [];
    const parser = new Parser(
        tokenize(s, args as string[]),
        args,
        macros,
        (err) => {
            if (typeof onError === 'function') {
                onError({ ...err, latex: s });
            } else {
                // console.warn(
                //     'MathLive parsing error: ' +
                //         err.code +
                //         (err.arg ? ' ' + err.arg + ' ' : ''),
                //     'in "' + s + '"'
                // );
            }
        }
    );
    parser.parseMode = parseMode || 'math'; // other possible values: 'text', 'color', etc...
    if (smartFence) parser.smartFence = true;

    while (!parser.end()) {
        const more = parser.parse();
        if (more) {
            atoms = atoms.concat(more);
        }
    }
    return atoms;
}
