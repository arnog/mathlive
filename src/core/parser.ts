import {
  ErrorListener,
  MacroDefinition,
  Style,
  ParserErrorCode,
  MacroDictionary,
  ParseMode,
} from '../public/core';

import { isArray } from '../common/types';

import { stringToColor } from './color';
import { convertDimenToEm } from './font-metrics';
import { Token, tokenize, tokensToString } from './tokenizer';
import { Atom, BBoxParameter } from './atom-class';
import { Mode } from './modes-utils';
import {
  Argument,
  FunctionDefinition,
  getEnvironmentDefinition,
  getInfo,
  SymbolDefinition,
} from '../core-definitions/definitions-utils';
import { Colspec } from '../core-atoms/array';
import { GroupAtom } from '../core-atoms/group';
import { SpacingAtom } from '../core-atoms/spacing';
import { LeftRightAtom } from '../core-atoms/leftright';
import { SubsupAtom } from '../core-atoms/subsup';
import { PlaceholderAtom } from '../core-atoms/placeholder';
import { ErrorAtom } from '../core-atoms/error';
import { MacroAtom } from '../core-atoms/macro';
import { ArgumentType } from './context';
import { TextAtom } from '../core-atoms/text';

// Performance to check first char of string: https://jsben.ch/QLjdZ

function isLiteral(token: Token): boolean {
  return !/^<({|}|\$|\$\$|space)>$/.test(token);
}

/**
 * Transform a list of tokens into a list of atoms.
 *

 * @property tokens - An array of tokens generated by the lexer.
 * @property args - Optional arguments to substitute the `#` token.
 * @property macros - A dictionary of objects, index by the name of
 * the macro, with the following keys:
 *    * args: an integer, the number of arguments, default 0. They can be referenced as #0,
 *       #1, #2... inside the definition of the macro
 *    * def: a string, the definition of the macro, which can reference other macros
 * @property index - The current token to be parsed: index in `this.tokens`
 * @property atoms - Accumulated result of the parsing by
 * `parseAtom()`
 * @property style - The font, weight, color, etc. to apply to the
 * upcoming tokens
 * @property parseMode - The parse mode indicates the syntax rules to
 * use to parse the upcoming tokens.
 * @property tabularMode - When in tabular mode, `'&'` is interpreted as
 *  a column separator and `'\'` as a row separator. Used for matrixes, etc...
 * @property endCount - Counter to prevent deadlock. If `end()` is
 * called too many times (1,000) in a row for the same token, bail.
 */
class Parser {
  tokens: Token[];
  index = 0;

  args: null | (string | Atom[])[];
  macros: MacroDictionary;

  style: Style = {};
  parseMode: ParseMode = 'math';
  smartFence = false;
  tabularMode = false; // For arrays, matrix, etc.: ifferent parsing rules apply.

  atoms: Atom[] = [];

  endCount = 0;
  onError: ErrorListener<ParserErrorCode>;

  /**
   * @param tokens - An array of tokens generated by the lexer.
   * @param args - An optional list of arguments. `#n` tokens will be
   * substituted with the corresponding element in the args object. This is used
   * when parsing macros.
   */
  constructor(
    tokens: Token[],
    args: null | (string | Atom[])[],
    macros: MacroDictionary,
    onError: ErrorListener<ParserErrorCode>
  ) {
    this.tokens = tokens;
    this.args = args;
    this.macros = macros;
    this.onError = (err): void =>
      onError({
        before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
        after: tokensToString(
          this.tokens.slice(Math.max(0, this.index - 10), this.index)
        ),
        ...err,
      });
  }

  swapAtoms(newAtoms: Atom[] = []): Atom[] {
    const result = this.atoms;
    this.atoms = newAtoms;
    return result;
  }

  swapParseMode(mode: ParseMode): ParseMode {
    const result = this.parseMode;
    this.parseMode = mode;
    return result;
  }

  /**
   * True if we've reached the end of the token stream
   */
  end(): boolean {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
  }

  get(): Token {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : '';
  }

  peek(): Token {
    return this.tokens[this.index];
  }

  /**
   * @return True if the next token matches the input, and advance
   */
  match(input: string): boolean {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * Return the last atom that can have a subsup attached to it.
   * If there isn't one, insert a `msubsup` and return it.
   */
  lastSubsupAtom(): Atom {
    const lastAtom =
      this.atoms.length === 0 ? undefined : this.atoms[this.atoms.length - 1];
    if (
      !lastAtom ||
      (lastAtom.type !== 'mop' &&
        lastAtom.type !== 'leftright' &&
        lastAtom.type !== 'msubsup')
    ) {
      if (!lastAtom?.limits || lastAtom?.limits === 'nolimits') {
        this.atoms.push(new SubsupAtom({ baseType: lastAtom?.type }));
      }
    }

    return this.atoms[this.atoms.length - 1];
  }

  /**
   * @return True if the next token matches the specified regular expression pattern.
   */
  hasPattern(pattern: RegExp): boolean {
    return pattern.test(this.tokens[this.index]);
  }

  hasInfixCommand(): boolean {
    const { index } = this;
    if (index < this.tokens.length && this.tokens[index].startsWith('\\')) {
      const info = getInfo(this.tokens[index], this.parseMode, this.macros);
      if (!info) return false;
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
        return false;
      }

      return info.infix;
    }

    return false;
  }

  matchColumnSeparator(): boolean {
    const { index } = this;
    if (this.tabularMode && this.tokens[index] === '&') {
      this.index++;
      return true;
    }

    return false;
  }

  matchRowSeparator(): boolean {
    const { index } = this;
    if (
      this.tabularMode &&
      (this.tokens[index] === '\\\\' || this.tokens[index] === '\\cr')
    ) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * Return the appropriate value for a placeholder, either a default
   * one, or if a value was provided for #? via args, that value.
   */
  placeholder(): Atom[] {
    if (!this.args || this.args['?'] === undefined) {
      return [
        new PlaceholderAtom({
          mode: this.parseMode,
          style: this.style,
        }),
      ];
    }

    if (typeof this.args?.['?'] === 'string') {
      // If there is a specific value defined for the placeholder,
      // use it.
      return parseLatex(
        this.args['?'],
        this.parseMode,
        null,
        this.macros,
        false,
        this.onError
      );
    }

    return this.args['?'];
  }

  // MatchToken(type: string): boolean {
  //     if (this.hasToken(type)) {
  //         this.index++;
  //         return true;
  //     }
  //     return false;
  // }
  matchWhitespace(): boolean {
    let found = false;
    while (this.match('<space>')) {
      found = true;
    }

    return found;
  }

  skipUntilToken(input: string): void {
    let token = this.tokens[this.index];
    while (token && token !== input) {
      token = this.tokens[++this.index];
    }

    if (token === input) {
      this.index++;
    }
  }

  skipFiller(): void {
    let done = false;
    do {
      const skippedSpace = this.matchWhitespace();
      const skippedRelax = this.match('\\relax');
      done = !skippedSpace && !skippedRelax;
    } while (!done);
  }

  /**
   * Keywords are used to specify dimensions, and for various other
   * syntactic constructs.
   *
   * Unlike commands, they are not case sensitive.
   *
   * There are 25 keywords:
   *
   * at by bp cc cm dd depth em ex fil fill filll height in minus
   * mm mu pc plus pt sp spread to true width
   *
   * TeX: 8212
   * @return true if the expected keyword is present
   */
  matchKeyword(keyword: string): boolean {
    const savedIndex = this.index;
    let done = this.end();
    let value = '';
    while (!done) {
      const token = this.get();
      if (isLiteral(token)) {
        value += token;
        done = this.end() || value.length >= keyword.length;
      } else {
        done = true;
      }
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) {
      this.index = savedIndex;
    }

    return hasKeyword;
  }

  /**
   * Return a sequence of characters as a string.
   * i.e. 'abcd' returns 'abcd'.
   * Terminates on the first non-literal token encountered
   * e.g. '<{>', '<}>' etc...
   * Will also terminate on character literal ']'
   */
  scanString(): string {
    let result = '';
    let done = this.end();
    while (!done) {
      if (this.match('<space>')) {
        result += ' ';
      } else {
        const token = this.peek();
        if (token === ']') {
          done = true;
        } else if (isLiteral(token)) {
          result += this.get();
        } else if (token.startsWith('\\')) {
          // TeX will give a 'Missing \endcsname inserted' error
          // if it encounters any command when expecting a string.
          // We're a bit more lax.
          this.onError({ code: 'unbalanced-braces' });
          result += this.get();
        } else {
          // It's '<{>', '<}>', '<$>' or '<$$>
          done = true;
        }
      }

      done = done || this.end();
    }

    return result;
  }

  /**
   * Return a sequence of characters as a string.
   * Terminates on a balanced closing bracket
   * This is used by the `\ce` command
   */
  scanBalancedString(): string {
    let result = '';
    let done = this.end();
    let level = 1;
    while (!done) {
      if (this.match('<space>')) {
        result += ' ';
      } else {
        const token = this.get();
        if (token === '<{>') {
          result += '{';
          level += 1;
        } else if (token === '<}>') {
          level -= 1;
          if (level > 0) {
            result += '}';
          } else {
            this.index -= 1;
          }
        } else if (token === '<$>') {
          result += '$';
        } else if (token === '<$$>') {
          result += '$$';
        } else {
          result += token;
        }
      }

      done = level === 0 || this.end();
    }

    return result;
  }

  /**
   * Return the literal tokens, as a string, until a matching closing "}"
   */
  matchLiteralArg(): string {
    let result = '';
    if (this.match('<{>')) {
      let depth = 1;
      while (depth > 0 && !this.end()) {
        const token = this.get()!;
        if (token === '<}>') {
          depth -= 1;
          if (depth > 0) {
            // Don't include final '}'
            result += '}';
          }
        } else if (token === '<{>') {
          depth += 1;
          result += '{';
        } else {
          result +=
            {
              '<space>': ' ',
              '<$$>': '$$',
              '<$>': '$',
            }[token] ?? token;
        }
      }
    }

    return result;
  }

  /**
   * Return a CSS color (#rrggbb)
   */
  scanColor(): string {
    return stringToColor(this.scanString());
  }

  /**
   * Return as a number a group of characters representing a
   * numerical quantity.
   *
   * From TeX:8695 (scan_int):
   * An integer number can be preceded by any number of spaces and `+' or
   * `-' signs. Then comes either a decimal constant (i.e., radix 10), an
   * octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
   * (radix 16, preceded by "), an alphabetic constant (preceded by `), or
   * an internal variable.
   */
  scanNumber(isInteger = true): number {
    let negative = false;
    let token = this.peek();
    while (token === '<space>' || token === '+' || token === '-') {
      this.get();
      if (token === '-') negative = !negative;
      token = this.peek();
    }

    isInteger = Boolean(isInteger);

    let radix = 10;
    let digits = /\d/;
    if (this.match("'")) {
      // Apostrophe indicates an octal value
      radix = 8;
      digits = /[0-7]/;
      isInteger = true;
    } else if (this.match('"') || this.match('x')) {
      // Double-quote indicates a hex value
      // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
      // For example: 'x3a'
      radix = 16;
      // Hex digits have to be upper-case
      digits = /[\dA-F]/;
      isInteger = true;
    } else if (this.match('`')) {
      // A backtick indicates an alphabetic constant: a letter, or a single-letter command
      token = this.get();
      if (token) {
        if (token.startsWith('\\') && token.length === 2) {
          return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
        }

        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }

      return Number.NaN;
    }

    let value = '';
    while (this.hasPattern(digits)) {
      value += this.get();
    }

    // Parse the fractional part, if applicable
    if (!isInteger && (this.match('.') || this.match(','))) {
      value += '.';
      while (this.hasPattern(digits)) {
        value += this.get();
      }
    }

    const result = isInteger
      ? Number.parseInt(value, radix)
      : Number.parseFloat(value);
    return negative ? -result : result;
  }

  /**
   * Return as a floating point number a dimension in pt (1 em = 10 pt)
   *
   * See TeX:8831
   * @todo: note that some units depend on the font (em, ex). So it might be
   * better to return a dimen struct with the value + unit and resolve
   * later when we have a font context....
   */
  scanDimen(): number {
    const value = this.scanNumber(false);
    this.matchWhitespace();
    let result: number;
    if (this.matchKeyword('pt')) {
      result = convertDimenToEm(value, 'pt');
    } else if (this.matchKeyword('mm')) {
      result = convertDimenToEm(value, 'mm');
    } else if (this.matchKeyword('cm')) {
      result = convertDimenToEm(value, 'cm');
    } else if (this.matchKeyword('ex')) {
      result = convertDimenToEm(value, 'ex');
    } else if (this.matchKeyword('px')) {
      result = convertDimenToEm(value, 'px');
    } else if (this.matchKeyword('em')) {
      result = convertDimenToEm(value, 'em');
    } else if (this.matchKeyword('bp')) {
      result = convertDimenToEm(value, 'bp');
    } else if (this.matchKeyword('dd')) {
      result = convertDimenToEm(value, 'dd');
    } else if (this.matchKeyword('pc')) {
      result = convertDimenToEm(value, 'pc');
    } else if (this.matchKeyword('in')) {
      result = convertDimenToEm(value, 'in');
    } else if (this.matchKeyword('mu')) {
      result = convertDimenToEm(value, 'mu');
    } else {
      // If the units are missing, TeX assumes 'pt'
      this.onError({ code: 'missing-unit' });
      result = convertDimenToEm(value, 'pt');
    }

    return result;
  }

  scanSkip(): number {
    const result = this.scanDimen();
    // We parse, but ignore, the optional 'plus' and 'minus'
    // arguments.
    this.matchWhitespace();
    // 'plus', optionally followed by 'minus'
    // ('minus' cannot come before 'plus')
    // dimen or 'hfill'
    if (this.matchKeyword('plus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    this.matchWhitespace();
    if (this.matchKeyword('minus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    return result;
  }

  scanColspec(): Colspec[] {
    this.matchWhitespace();
    const result: Colspec[] = [];
    while (!this.end() && !(this.peek() === '<}>' || this.peek() === ']')) {
      const literal = this.get();
      if (literal === 'c' || literal === 'r' || literal === 'l') {
        result.push({ align: literal });
      } else if (literal === '|') {
        result.push({ rule: true });
      } else if (literal === '@') {
        if (this.match('<{>')) {
          const savedParsemode = this.swapParseMode('math');
          result.push({
            gap: this.parse((token) => token === '<}>'),
          });
          this.swapParseMode(savedParsemode);
        }

        if (!this.match('<}>')) {
          this.onError({ code: 'unbalanced-braces' });
        }
      }
    }

    return result;
  }

  /**
   * Parse a `\(...\)` or `\[...\]` sequence
   * @return group for the sequence or null
   */
  parseModeSet(): Atom | null {
    let final: Token = '';
    if (this.match('\\(')) final = '\\)';
    if (!final && this.match('\\[')) final = '\\]';
    if (!final) return null;
    const savedParsemode = this.swapParseMode('math');
    const result = new GroupAtom(
      this.parse((token) => token === final),
      {
        mathStyleName: final === '\\)' ? 'textstyle' : 'displaystyle',
        latexOpen: final === '\\]' ? '\\[' : '\\(',
        latexClose: final,
      }
    );
    if (!this.match(final)) {
      this.onError({ code: 'unbalanced-mode-shift' });
    }

    this.swapParseMode(savedParsemode);
    if (result.hasEmptyBranch('body')) return null;

    return result;
  }

  /**
   * Parse a `$...$` or `$$...$$` sequence
   */
  parseModeShift(): Atom | null {
    let final: Token = '';
    if (this.match('<$>')) final = '<$>';
    if (!final && this.match('<$$>')) final = '<$$>';
    if (!final) return null;

    const savedParsemode = this.swapParseMode('math');

    const result = new GroupAtom(
      this.parse((token: Token) => token === final),
      {
        mathStyleName: final === '<$>' ? 'textstyle' : 'displaystyle',
        latexOpen: final === '<$>' ? '$' : '$$',
        latexClose: final === '<$>' ? '$' : '$$',
      }
    );
    if (!this.match(final)) {
      this.onError({ code: 'unbalanced-mode-shift' });
    }

    this.swapParseMode(savedParsemode);
    if (result.hasEmptyBranch('body')) return null;
    return result;
  }

  /**
   * Parse a \begin{env}...\end{end} sequence
   */
  parseEnvironment(): Atom | null {
    // An environment starts with a \begin command
    if (!this.match('\\begin')) return null;

    // The \begin command is immediately followed by the environment
    // name, as a string argument
    const envName = this.parseArgument('string');
    if (!envName) return null;
    const def = getEnvironmentDefinition(envName);
    if (!def) {
      this.onError({
        code: 'unknown-environment',
        arg: envName,
      });
      return null;
    }

    // If the environment has some arguments, parse them
    const args: Argument[] = [];
    if (def.params) {
      for (const parameter of def.params) {
        // Parse an argument
        if (parameter.isOptional) {
          // If it's not present, parseOptionalArgument returns null,
          // but push it on the list of arguments anyway.
          // The null value will be interpreted as unspecified
          // optional value by the command parse function.
          args.push(this.parseOptionalArgument(parameter.type));
        } else {
          const arg: Argument = this.parseArgument(parameter.type);
          if (!arg) {
            this.onError({
              code: 'missing-argument',
              arg: envName,
            });
          }

          args.push(arg);
        }
      }
    }

    // Some environments change the mode
    const savedMode = this.parseMode;
    const savedTabularMode = this.tabularMode;
    const saveAtoms = this.swapAtoms([]);
    // @todo: since calling scanImplicitGroup(), may not need to save/restore the atoms
    this.tabularMode = def.tabular;
    const array: Atom[][][] = [];
    const rowGaps: number[] = [];
    let row: Atom[][] = [];
    let done = false;
    do {
      if (this.end()) {
        this.onError({ code: 'unbalanced-environment', arg: envName });
        done = true;
      }

      if (!done && this.match('\\end')) {
        if (this.parseArgument('string') !== envName) {
          this.onError({
            code: 'unbalanced-environment',
            arg: envName,
          });
        }

        done = true;
      }

      if (!done) {
        if (this.matchColumnSeparator()) {
          row.push(this.swapAtoms([]));
        } else if (this.matchRowSeparator()) {
          row.push(this.swapAtoms([]));
          let gap = 0;
          this.matchWhitespace();
          if (this.match('[')) {
            gap = this.scanDimen();
            this.matchWhitespace();
            this.match(']');
          }

          rowGaps.push(gap || 0);
          array.push(row);
          row = [];
        } else {
          this.atoms = this.atoms.concat(
            this.parse(
              (token: Token) =>
                token === '<}>' ||
                token === '&' ||
                token === '\\end' ||
                token === '\\cr' ||
                token === '\\\\'
            )
          );
        }
      }
    } while (!done);

    row.push(this.swapAtoms([]));
    if (row.length > 0) array.push(row);
    const newAtoms = this.swapAtoms(saveAtoms);
    // If we're in tabular mode, we should end up with an empty atoms list
    console.assert(
      !this.tabularMode || newAtoms.length === 0,
      'Leftover atoms in tabular mode'
    );
    this.parseMode = savedMode;
    this.tabularMode = savedTabularMode;

    if (!def.tabular && newAtoms.length === 0) return null;
    if (def.tabular && array.length === 0) return null;

    return def.createAtom(envName, array, rowGaps, args);
  }

  /**
   * Parse a sequence until a group end marker, such as
   * `}`, `\end`, `&`, etc...
   *
   * Returns an array of atoms or an empty array if the sequence
   * terminates right away.
   *
   * @param done - A predicate indicating if a
   * token signals the end of an implicit group
   */
  parse(done?: (token: Token) => boolean): Atom[] {
    const savedStyle = this.style;
    if (!done) {
      // Default group end marker
      done = (token: Token): boolean => token === '<}>';
    }

    // To handle infix commands, we'll keep track of their prefix
    // (tokens coming before them) and their arguments
    let infix: Token = '';
    let infixInfo: (FunctionDefinition & SymbolDefinition) | null = null;
    let infixArgs: Atom[][] = [];
    let prefix: Atom[] | null = null;
    const saveAtoms = this.swapAtoms([]);
    while (!this.end() && !done(this.peek())) {
      if (this.hasInfixCommand() && !infix) {
        // The next token is an infix and we have not seen one yet
        // (there can be only one infix command per implicit group).
        infix = this.get();
        // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode
        infixInfo = getInfo(infix, 'math', this.macros);
        if (infixInfo) {
          infixArgs = this.parseArguments(infixInfo)[1] as Atom[][];
        }

        // Save the math list so far and start a new one
        prefix = this.swapAtoms([]);
      } else {
        this.parseToken();
      }
    }

    let result: Atom[];
    if (infix) {
      console.assert(Boolean(infixInfo));
      infixArgs.unshift(this.swapAtoms(saveAtoms)); // Suffix
      if (prefix) infixArgs.unshift(prefix);
      result = [infixInfo.createAtom(infix, infixArgs, this.style)];
    } else {
      result = this.swapAtoms(saveAtoms);
    }

    this.style = savedStyle;

    return result;
  }

  /**
   * Parse a group enclosed in a pair of braces: `{...}`.
   *
   * Return either a group Atom or null if not a group.
   *
   * Return a group Atom with an empty body if an empty
   * group (i.e. `{}`).
   */
  parseGroup(): Atom | null {
    if (!this.match('<{>')) return null;
    const result = new GroupAtom(
      this.parse((token: Token) => token === '<}>'),
      {
        mode: this.parseMode,
        latexOpen: '{',
        latexClose: '}',
      }
    );
    if (!this.match('<}>')) {
      this.onError({ code: 'unbalanced-braces' });
    }

    return result;
  }

  scanSmartFence(): Atom | null {
    this.matchWhitespace();
    if (!this.match('(')) return null;
    // We've found an open paren... Convert to a `\mleft...\mright`
    const saveAtoms = this.swapAtoms([]);
    let nestLevel = 1;
    while (!this.end() && nestLevel !== 0) {
      if (this.match('(')) nestLevel += 1;
      if (this.match(')')) nestLevel -= 1;
      if (nestLevel !== 0) this.parseToken();
    }

    if (nestLevel === 0) this.match(')');
    return new LeftRightAtom(this.swapAtoms(saveAtoms), {
      inner: false,
      leftDelim: '(',
      rightDelim: nestLevel === 0 ? ')' : '?',
    });
  }

  /**
   * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
   *
   * @return The delimiter (as a character or command) or null
   */
  scanDelim(): string | null {
    this.matchWhitespace();
    const token = this.get();
    if (!token) {
      this.onError({ code: 'unexpected-end-of-string' });
      return null;
    }

    let delim = '.';
    if (token.startsWith('\\') || isLiteral(token)) {
      delim = token;
    }

    const info = getInfo(delim, 'math', this.macros);
    if (!info) {
      this.onError({ code: 'unknown-command', arg: delim });
      return null;
    }

    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      this.onError({ code: 'unexpected-delimiter', arg: delim });
      return null;
    }

    if (info.type === 'mopen' || info.type === 'mclose') {
      return delim;
    }

    // Some symbols are not of type mopen/mclose, but are still
    // valid delimiters...
    // '?' is a special delimiter used as a 'placeholder'
    // (when the closing delimiter is displayed greyed out)
    if (
      /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
        delim
      )
    ) {
      return delim;
    }

    this.onError({ code: 'unexpected-delimiter', arg: delim });
    return null;
  }

  /**
   * Parse a `/left.../right` sequence.
   *
   * Note: the `/middle` command can occur multiple times inside a
   * `/left.../right` sequence, and is handled separately.
   *
   * Return either an atom of type `'leftright'` or null
   */
  parseLeftRight(): Atom | null {
    if (this.match('\\right') || this.match('\\mright')) {
      // We have an unbalanced left/right (there's a \right, but no \left)
      this.onError({ code: 'unbalanced-braces' });
      return null;
    }

    const savedStyle = this.style;

    let close = '\\right';
    if (!this.match('\\left')) {
      if (!this.match('\\mleft')) return null;
      close = '\\mright';
    }

    const leftDelim = this.scanDelim();
    if (!leftDelim) return null;

    const saveAtoms = this.swapAtoms([]);
    while (!this.end() && !this.match(close)) {
      this.parseToken();
    }

    this.style = savedStyle;

    // If we've reached the end and there was no `\right` or
    // there isn't a valid delimiter after `\right`, we'll
    // consider the `\right` missing and set the `rightDelim` to undefined
    const rightDelim = this.scanDelim();

    return new LeftRightAtom(this.swapAtoms(saveAtoms), {
      leftDelim,
      rightDelim,
      inner: close === '\\right',
      style: this.style,
    });
  }

  /**
   * Parse a subscript/superscript: `^` and `_`.
   *
   * Modify the last atom accordingly, or create a new 'msubsup' carrier.
   *
   */
  parseSupSub(): boolean {
    // No sup/sub in text or command mode.
    if (this.parseMode !== 'math') return false;
    // Apply the subscript/superscript to the last rendered atom.
    // If none is present (beginning of the list, i.e. `{^2}`,
    // an empty atom will be created, equivalent to `{{}^2}`
    let result = false;
    let token = this.peek();
    while (token === '^' || token === '_' || token === "'") {
      const supsub = token === '_' ? 'subscript' : 'superscript';
      if (this.match('^') || this.match('_')) {
        const arg = this.parseArgument('math');
        if (arg) {
          this.lastSubsupAtom().addChildren(arg, supsub);
          result = true;
        }
      } else if (this.match("'")) {
        // A single quote (prime) is actually equivalent to a
        // '^{\prime}'
        this.lastSubsupAtom().addChild(
          new Atom('mord', {
            command: '\\prime',
            mode: 'math',
            value: '\u2032',
          }),
          'superscript'
        );
        result = true;
      }

      token = this.peek();
    }

    return result;
  }

  /**
   * Parse a `\limits` or `\nolimits` command.
   *
   * This will change the placement of limits to be either above or below
   * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
   *
   * This overrides the calculation made for the placement, which is usually
   * dependent on the displaystyle (`inlinemath` prefers `\nolimits`, while
   * `displaymath` prefers `\limits`).
   */
  parseLimits(): boolean {
    // Note: technically, \limits and \nolimits are only applicable
    // after an operator. However, we apply them in all cases. They
    // will simply be ignored when not applicable (i.e. on a literal)
    // which is actually consistent with TeX.
    if (this.match('\\limits')) {
      const lastAtom = this.lastSubsupAtom();
      lastAtom.limits = 'limits';
      // Record that the limits was set through an explicit command
      // so we can generate the appropriate LaTeX later
      lastAtom.explicitLimits = true;
      return true;
    }

    if (this.match('\\nolimits')) {
      const lastAtom = this.lastSubsupAtom();
      lastAtom.limits = 'nolimits';
      // Record that the limits was set through an explicit command
      // so we can generate the appropriate LaTeX later
      lastAtom.explicitLimits = true;
      return true;
    }

    return false;
  }

  parseArguments(info: FunctionDefinition): [ParseMode, Argument[]] {
    if (!info || !info.params) return [undefined, []];
    let explicitGroup: ParseMode;
    const args: Argument[] = [];
    let i = info.infix ? 2 : 0;
    while (i < info.params.length) {
      const parameter = info.params[i];
      // Parse an argument
      if (parameter.isOptional) {
        args.push(this.parseOptionalArgument(parameter.type));
      } else if (parameter.type.endsWith('*')) {
        // For example 'math*'.
        // In this case, indicate that a 'yet-to-be-parsed'
        // argument (and 'explicit group') is present
        explicitGroup = parameter.type.slice(0, -1) as ParseMode;
      } else {
        const arg = this.parseArgument(parameter.type);
        if (arg !== undefined) {
          args.push(arg);
        } else {
          // Report an error
          this.onError({ code: 'missing-argument' });
          args.push(this.placeholder());
        }
      }

      i += 1;
    }

    return [explicitGroup, args];
  }

  /**
   * Parse a math field (in the TeX parlance), an argument to a function.
   *
   * An argument can either be a single atom or  a sequence of atoms enclosed
   * in braces.
   *
   */
  parseArgument(argType: 'auto'): Atom[];
  parseArgument(argType: ParseMode): Atom[];
  parseArgument(argType: 'balanced-string'): string;
  parseArgument(argType: 'color'): string;
  parseArgument(argType: 'colspec'): Colspec[];
  parseArgument(argType: 'delim'): string;
  parseArgument(argType: 'dimen'): number;
  parseArgument(argType: 'number'): number;
  parseArgument(argType: 'skip'): number;
  parseArgument(argType: 'string'): string;
  parseArgument(argType: ArgumentType): Argument;
  parseArgument(argType: ArgumentType): Argument {
    this.skipFiller();
    argType = argType === 'auto' ? this.parseMode : argType;
    let result: string | number | Atom[] | Colspec[];
    // An argument (which is called a 'math field' in TeX)
    // could be a single character or symbol, as in `\frac12`
    // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
    // ``\frac{\sqrt}{-1}{\beta}``
    if (!this.match('<{>')) {
      if (argType === 'delim') {
        return this.scanDelim() ?? '.';
      }

      if (argType === 'text' || argType === 'math') {
        // Parse a single token.
        const savedParseMode = this.swapParseMode(argType);
        const atom = this.parseSimpleToken();
        this.swapParseMode(savedParseMode);
        return atom;
      }
    }

    const saveAtoms = this.swapAtoms([]);
    if (argType === 'text' || argType === 'math') {
      const savedParseMode = this.parseMode;
      this.parseMode = argType;

      // Collect an array of tokens until a balanced "}"
      const initialIndex = this.index;
      let depth = 1;
      do {
        const token = this.get();
        if (token === '<}>') depth -= 1;
        if (token === '<{>') depth += 1;
      } while (depth > 0 && !this.end());

      result = Mode.parseTokens(
        argType,
        this.tokens.slice(initialIndex, this.index - 1),
        this.onError,
        {
          args: this.args,
          macros: this.macros,
          smartFence: this.smartFence,
          style: this.style,
          parse: (
            mode: ParseMode,
            tokens: Token[],
            options
          ): [Atom[], Token[]] => {
            const parser = new Parser(
              tokens,
              options.args,
              options.macros,
              this.onError
            );
            parser.parseMode = mode;
            parser.style = options.style;
            result = parser.parse();
            return [result, tokens.slice(parser.index)];
          },
        }
      );
      if (!result) {
        // No mode-specific result. Try again from the start
        this.index = initialIndex;
        do {
          this.atoms = this.atoms.concat(this.parse());
        } while (!this.match('<}>') && !this.end());
      }

      this.parseMode = savedParseMode;
    } else {
      if (argType === 'string') {
        result = this.scanString();
      } else if (argType === 'balanced-string') {
        result = this.scanBalancedString();
      } else if (argType === 'number') {
        result = this.scanNumber();
      } else if (argType === 'dimen') {
        result = this.scanDimen();
      } else if (argType === 'skip') {
        result = this.scanSkip();
      } else if (argType === 'colspec') {
        result = this.scanColspec();
      } else if (argType === 'color') {
        result = this.scanColor() || '#ffffff';
      } else if (argType === 'delim') {
        result = this.scanDelim() || '.';
      }

      this.skipUntilToken('<}>');
    }

    const atoms = this.swapAtoms(saveAtoms);
    return result ?? atoms;
  }

  parseOptionalArgument(parseMode: ArgumentType): Argument {
    parseMode = parseMode === 'auto' ? this.parseMode : parseMode;
    this.matchWhitespace();
    if (!this.match('[')) return null;
    const savedParseMode = this.parseMode;
    const saveAtoms = this.swapAtoms();
    let result: Argument;
    while (!this.end() && !this.match(']')) {
      if (parseMode === 'string') {
        result = this.scanString();
      } else if (parseMode === 'number') {
        result = this.scanNumber();
      } else if (parseMode === 'dimen') {
        result = this.scanDimen();
      } else if (parseMode === 'skip') {
        result = this.scanSkip();
      } else if (parseMode === 'colspec') {
        result = this.scanColspec();
      } else if (parseMode === 'color') {
        result = this.scanColor() ?? '#ffffff';
      } else if (parseMode === 'bbox') {
        // The \bbox command takes a very particular argument:
        // a comma delimited list of up to three arguments:
        // a color, a dimension and a string.
        // Split the string by comma delimited sub-strings, ignoring commas
        // that may be inside (). For example"x, rgb(a, b, c)" would return
        // ['x', 'rgb(a, b, c)']
        const list = this.scanString()
          .toLowerCase()
          .trim()
          .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
        const bboxParameter: BBoxParameter = {};
        for (const element of list) {
          const color = stringToColor(element);
          if (color) {
            bboxParameter.backgroundcolor = color;
          } else {
            const m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
            if (m) {
              bboxParameter.padding = convertDimenToEm(m[1], m[2]);
            } else {
              const m = element.match(/^\s*border\s*:\s*(.*)/);
              if (m) {
                bboxParameter.border = m[1];
              }
            }
          }
        }

        result = bboxParameter;
      } else if (parseMode === 'math') {
        this.parseMode = parseMode;
        this.atoms = this.atoms.concat(this.parse((token) => token === ']'));
        this.parseMode = savedParseMode;
      }
    }

    const atoms = this.swapAtoms(saveAtoms);
    return result ?? atoms;
  }

  parseCommand(command: string): Atom[] {
    let result: Atom = null;
    if (command === '\\placeholder') {
      return [
        new PlaceholderAtom({
          mode: this.parseMode,
          value: this.parseArgument('string'),
          style: this.style,
        }),
      ];
    }

    if (command === '\\char') {
      // \char has a special syntax and requires a non-braced integer
      // argument
      const initialIndex = this.index;
      let codepoint = Math.floor(this.scanNumber(true));
      if (
        !Number.isFinite(codepoint) ||
        codepoint < 0 ||
        codepoint > 0x10ffff
      ) {
        codepoint = 0x2753; // BLACK QUESTION MARK
      }

      result = new Atom(this.parseMode === 'math' ? 'mord' : 'text', {
        command: '\\char',
        mode: this.parseMode,
        value: String.fromCodePoint(codepoint),
      });
      result.latex =
        '\\char' + tokensToString(this.tokens.slice(initialIndex, this.index));
      return [result];
    }

    if (command === '\\hskip' || command === '\\kern') {
      // \hskip and \kern have a special syntax and requires a non-braced
      // 'skip' argument
      const width = this.scanSkip();
      if (!Number.isFinite(width)) return null;
      return [new SpacingAtom(command, this.style, width)];
    }

    // Is this a macro?
    result = this.scanMacro(command);
    if (result) return [result];

    // This wasn't a macro, so let's see if it's a regular command
    const info = getInfo(command, this.parseMode, {});

    if (!info) {
      // An unknown command
      this.onError({
        code: 'unknown-command',
        arg: command,
      });
      return [new ErrorAtom(command)];
    }

    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      // Command invalid in this mode
      this.onError({
        code: 'invalid-command',
        arg: command,
      });
      return [new ErrorAtom(command)];
    }

    // Parse the arguments
    // If explicitGroup is not empty, an explicit group is expected
    // to follow the command and will be parsed *after* the
    // command has been processed.
    // This is used for commands such as \textcolor{color}{content}
    // that need to apply the color to the content *after* the
    // style has been changed.
    // In definitions, this is indicated with a parameter type
    // of 'auto*'

    const savedMode = this.parseMode;
    if (info.applyMode) {
      this.parseMode = info.applyMode;
    }

    const initialIndex = this.index;
    const [explicitGroup, args] = this.parseArguments(info);
    this.parseMode = savedMode;

    if (!args) return null; // Some required arguments were missing...

    if (info.applyMode && !info.applyStyle && !info.createAtom) {
      return args[0] as Atom[];
    }

    if (info.infix) {
      // Infix commands should be handled in scanImplicitGroup
      // If we find an infix command here, it's a syntax error
      // (second infix command in a group) and should be ignored.
      this.onError({
        code: 'too-many-infix-commands',
        arg: command,
      });
      return null;
    }

    //  Invoke the createAtom() function if present
    if (typeof info.createAtom === 'function') {
      result = info.createAtom(command, args, this.style);
      if (explicitGroup) {
        result.body = this.parseArgument(explicitGroup);
      }
    } else if (typeof info.applyStyle === 'function') {
      const style = info.applyStyle(command, args);
      // No type provided -> the parse function will modify
      // the current style rather than create a new Atom.
      const savedMode = this.parseMode;
      if (info.applyMode) {
        // Change to 'text' (or 'math') mode if necessary
        this.parseMode = info.applyMode;
      }

      // If an explicit group is expected, process it now
      if (explicitGroup) {
        // Create a temporary style
        const saveStyle = this.style;
        this.style = { ...this.style, ...style };
        const atoms = this.parseArgument(explicitGroup);
        this.style = saveStyle;
        this.parseMode = savedMode;
        return atoms;
      }

      // Merge the new style info with the current style
      this.style = { ...this.style, ...style };
      this.parseMode = savedMode;
    } else {
      // The new atom will inherit the current style
      // Only override the variant if it is not '' or undefined
      const style = {
        ...this.style,
        variant: info.variant ?? this.style.variant,
        // VariantStyle: info.variantStyle || this.style.variantStyle,
      };
      result =
        info.type === 'spacing'
          ? new SpacingAtom(command, this.style)
          : new Atom(info.type ?? 'mop', {
              command,
              style,
              value: info.value ?? command,
              mode: info.applyMode ?? this.parseMode,
            });
    }

    if (
      result instanceof Atom &&
      !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)
    ) {
      const argString = tokensToString(
        this.tokens.slice(initialIndex, this.index)
      );
      if (argString && result.command) {
        result.latex = result.command + argString;
      }

      if (result.isFunction && this.smartFence) {
        // The command was a function that may be followed by
        // an argument, like `\sin(`
        const smartFence = this.scanSmartFence();
        if (smartFence) return [result, smartFence];
      }
    }

    if (!result) return null;
    return [result];
  }

  parseLiteral(literal: string): Atom[] {
    const result = Mode.createAtom(this.parseMode, literal, {
      ...this.style,
    });

    if (result.isFunction && this.smartFence) {
      // The atom was a function that may be followed by
      // an argument, like `f(`.
      const smartFence = this.scanSmartFence();
      if (smartFence) return [result, smartFence];
    }

    return [result];
  }

  parseSimpleToken(): Atom[] {
    const token = this.get();
    if (!token) return null;

    if (token === '<space>') {
      if (this.parseMode === 'text') {
        return [new TextAtom(' ', ' ', this.style)];
      }

      return null;
    }

    if (token.startsWith('\\')) return this.parseCommand(token);

    if (isLiteral(token)) return this.parseLiteral(token);

    if (token === '<}>') {
      this.onError({ latex: '', code: 'unbalanced-braces' });
    } else {
      this.onError({
        latex: '',
        code: 'unexpected-token',
        arg: token,
      });
    }

    return null;
  }

  /**
   * Attempt to scan the macro name and return an atom list if successful.
   * Otherwise, it wasn't a macro.
   */
  scanMacro(macro: string): Atom {
    const macroName = macro.slice(1);
    if (!this.macros || !this.macros[macroName]) return null;
    const initialIndex = this.index;
    const args: (string | Atom[])[] = [];
    let def: string;
    let argCount = 0;
    if (typeof this.macros[macroName] === 'string') {
      def = this.macros[macroName] as string;
      // Let's see if there are arguments in the definition.
      if (/(^|[^\\])#1/.test(def)) argCount = 1;
      if (/(^|[^\\])#2/.test(def)) argCount = 2;
      if (/(^|[^\\])#3/.test(def)) argCount = 3;
      if (/(^|[^\\])#4/.test(def)) argCount = 4;
      if (/(^|[^\\])#5/.test(def)) argCount = 5;
      if (/(^|[^\\])#6/.test(def)) argCount = 6;
      if (/(^|[^\\])#7/.test(def)) argCount = 7;
      if (/(^|[^\\])#8/.test(def)) argCount = 8;
      if (/(^|[^\\])#9/.test(def)) argCount = 9;
    } else {
      def = (this.macros[macroName] as MacroDefinition).def;
      argCount = (this.macros[macroName] as MacroDefinition).args || 0;
    }

    for (let i = 1; i <= argCount; i++) {
      // Parse each argument as a string. We don't know yet
      // what the proper parse mode is, so defer parsing till later
      // when invoking `parseString`
      args[i] = this.matchLiteralArg();
    }

    // Carry forward the placeholder argument, if any.
    args['?'] = this.args?.['?'];

    // Group the result of the macro expansion
    return new MacroAtom(
      macro,
      tokensToString(this.tokens.slice(initialIndex, this.index)),
      parseLatex(def, this.parseMode, args, this.macros, false, this.onError)
    );
  }

  /**
   * Make an atom for the current token or token group and
   * add it to the parser's current atoms
   */
  parseToken(): boolean {
    let result: Atom | Atom[] =
      this.parseEnvironment() ||
      this.parseModeShift() ||
      this.parseModeSet() ||
      this.parseGroup() ||
      this.parseLeftRight();
    if (!result && (this.parseSupSub() || this.parseLimits())) return true;
    if (!result) result = this.parseSimpleToken();
    // If we have an atom to add, push it at the end of the current math list
    // We could have no atom for tokens that were skipped, a ' ' in math mode
    // for example
    if (isArray(result)) {
      this.atoms = this.atoms.concat(result);
    } else if (result) {
      this.atoms.push(result);
    }

    return result !== null;
  }
}

/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
export function parseLatex(
  s: string,
  parseMode: ParseMode,
  args: null | (string | Atom[])[] = null,
  macros: null | MacroDictionary = null,
  smartFence = false,
  onError?: ErrorListener<ParserErrorCode>
): Atom[] {
  const parser = new Parser(
    tokenize(s, args as string[]),
    args,
    macros,
    (err) => {
      if (typeof onError === 'function') {
        onError({ ...err, latex: s });
      } else {
        // Console.warn(
        //     'MathLive parsing error: ' +
        //         err.code +
        //         (err.arg ? ' ' + err.arg + ' ' : ''),
        //     'in "' + s + '"'
        // );
      }
    }
  );
  parser.parseMode = parseMode ?? 'math'; // Other possible values: 'text', 'color', etc...
  if (smartFence) parser.smartFence = true;

  let atoms = [];
  while (!parser.end()) {
    const more = parser.parse();
    if (more) {
      atoms = atoms.concat(more);
    }
  }

  return atoms;
}
