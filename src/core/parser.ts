import type {
  ErrorListener,
  Style,
  ParserErrorCode,
  MacroDictionary,
  ParseMode,
  Registers,
  RegisterValue,
  Dimension,
  Glue,
} from '../public/core';

import { isArray } from '../common/types';

import { Token, tokenize, tokensToString } from './tokenizer';
import { Atom, BBoxParameter } from './atom-class';
import { Mode } from './modes-utils';
import {
  Argument,
  FunctionDefinition,
  NormalizedMacroDictionary,
  getEnvironmentDefinition,
  getInfo,
  getMacros,
} from '../core-definitions/definitions-utils';
import type { ColumnFormat } from '../core-atoms/array';
import { GroupAtom } from '../core-atoms/group';
import { SpacingAtom } from '../core-atoms/spacing';
import { LeftRightAtom } from '../core-atoms/leftright';
import { SubsupAtom } from '../core-atoms/subsup';
import { PlaceholderAtom } from '../core-atoms/placeholder';
import { ErrorAtom } from '../core-atoms/error';
import { MacroAtom } from '../core-atoms/macro';
import { TextAtom } from '../core-atoms/text';
import { defaultBackgroundColorMap, defaultColorMap } from './color';
import type { MathstyleName } from './mathstyle';

export type ArgumentType =
  | ParseMode
  | (
      | 'auto'
      | 'bbox'
      | 'colspec' // Formating of a column in tabular environment, e.g. `'r@{.}l'`
      | 'delim'
      | 'dimen' // `'25mu'`, `'2pt'`
      | 'number' // `+/-12.56`
      | 'rest' // `{\foo \textsize ...}` to capture "..."
      | 'glue' // `'25mu plus 2em minus fiLll'`, `'2pt'`
      | 'string' // The string will end on the first non-literal token, e.g. `<}>`
      | 'balanced-string' // Delimiter is a balanced closing brace
    );

// Performance to check first char of string: https://jsben.ch/QLjdZ

function isLiteral(token: Token): boolean {
  return !/^<({|}|\$|\$\$|space)>$/.test(token);
}

// The `ParsinContext` is the set of properties that get 'reset' when a
// new context is entered, essentially within a `{...}` or `[...]`...
// Their values are restored when the context is exited.

export type ParsingContext = {
  // The `parse()` function for a command can modify:
  // - the `mathlist` to examine the context of the command, modify atoms
  // in the current mathlist being constructed (e.g. `\limits`) or add
  // to the mathlist (when creating a new Atom)
  // - the `style` for commands that modify the font style, color, etc...
  // - the `parseMode` for commands that shift into math or text mode
  // - the `mathstyle` for commands such as `\displaystyle`
  mathlist: Atom[];
  style: Style;

  // The parser keeps track of the state of these variable, as they can
  // influence the parsing, e.g. the `\mathchoice` command
  parseMode: ParseMode;
  mathstyle: MathstyleName;
  registers: Registers | null;

  // When in tabular mode, `'&'` is interpreted as a column separator and
  // `'\\'` as a row separator. Used for matrixes, etc...
  tabular: boolean;
};

/**
 * Transform a list of tokens into a list of atoms (a mathlist in TeX's parlance)
 *
 */
export class Parser {
  // An array of tokens generated by the lexer
  tokens: Token[];

  // The current token to be parsed: index in `this.tokens`
  index = 0;

  macros?: NormalizedMacroDictionary;
  smartFence = false;

  // Optional arguments to substitute the `#` token.
  args: null | ((arg: string) => string);

  colorMap?: (name: string) => string | undefined;
  backgroundColorMap?: (name: string) => string | undefined;

  // Counter to prevent deadlock. If `end()` is called too many times (1,000)
  // in a row for the same token, bail.
  endCount = 0;

  onError: ErrorListener<ParserErrorCode>;
  _parsingContexts: ParsingContext[];

  /**
   * @param tokens - An array of tokens generated by the lexer.
   */
  constructor(
    tokens: Token[],
    options: {
      args?: null | ((arg: string) => string);
      macros?: NormalizedMacroDictionary;
      registers: Registers | null;
      onError?: ErrorListener<ParserErrorCode>;
      colorMap?: (name: string) => string | undefined;
      backgroundColorMap?: (name: string) => string | undefined;
      parseMode?: ParseMode;
      mathstyle?: MathstyleName;
      smartFence?: boolean;
      style?: Style;
    }
  ) {
    this.tokens = tokens;
    this.args = options.args ?? null;
    this.macros = options.macros;
    this.colorMap = options.colorMap;
    this.backgroundColorMap = options.backgroundColorMap ?? this.colorMap;
    this.smartFence = options.smartFence ?? false;
    this.onError = options.onError
      ? (err): void =>
          options.onError!({
            before: tokensToString(
              this.tokens.slice(this.index, this.index + 10)
            ),
            after: tokensToString(
              this.tokens.slice(Math.max(0, this.index - 10), this.index)
            ),
            ...err,
          })
      : () => {};
    this._parsingContexts = [
      {
        parseMode: options.parseMode ?? 'math',
        mathstyle: options.mathstyle ?? 'displaystyle',
        registers: options.registers,
        tabular: false,
        style: options.style ?? {},
        mathlist: [],
      },
    ];
  }

  // swapMathlist(atoms: Atom[]): Atom[] {
  //   const result = this.mathlist;
  //   this.mathlist = atoms;
  //   return result;
  // }

  // swapParseMode(mode: ParseMode): ParseMode {
  //   const result = this.parseMode;
  //   this.parseMode = mode;
  //   return result;
  // }

  get currentContext(): ParsingContext {
    return this._parsingContexts[this._parsingContexts.length - 1];
  }

  beginContext(options?: {
    mode?: ParseMode;
    mathstyle?: MathstyleName;
    tabular?: boolean;
  }): void {
    this._parsingContexts.push({
      parseMode: options?.mode ?? this.currentContext.parseMode,
      mathstyle: options?.mathstyle ?? this.currentContext.mathstyle,
      registers: null,
      style: { ...this.currentContext.style },
      tabular: options?.tabular ?? false,
      mathlist: [],
    });
  }

  endContext(): void {
    this._parsingContexts.pop();
  }

  get mathlist(): Atom[] {
    return this._parsingContexts[this._parsingContexts.length - 1].mathlist;
  }

  set mathlist(value: Atom[]) {
    this._parsingContexts[this._parsingContexts.length - 1].mathlist = value;
  }

  get parseMode(): ParseMode {
    return this._parsingContexts[this._parsingContexts.length - 1].parseMode;
  }

  // @revisit
  set parseMode(value: ParseMode) {
    this._parsingContexts[this._parsingContexts.length - 1].parseMode = value;
  }

  get tabularMode(): boolean {
    return this._parsingContexts[this._parsingContexts.length - 1].tabular;
  }

  get style(): Style {
    // Style is inherited
    let i = this._parsingContexts.length - 1;
    let result = this._parsingContexts[i].style;

    while (result === undefined && i > 0) {
      i -= 1;
      result = this._parsingContexts[i].style;
    }
    return result ?? {};
  }

  // @revisit
  set style(value: Style) {
    this._parsingContexts[this._parsingContexts.length - 1].style = value;
  }

  getRegister(name: string): RegisterValue {
    console.assert(name[0] !== '\\');
    if (name.startsWith('global ')) {
      return this._parsingContexts[0].registers?.[name.slice(7)] ?? 0;
    }
    let i = this._parsingContexts.length - 1;
    let registers = this._parsingContexts[i].registers;
    while (i >= 0 && registers && registers[name] === undefined) {
      i -= 1;
      registers = this._parsingContexts[i]?.registers;
    }
    return registers?.[name] ?? 0;
  }

  setRegister(name: string, value: RegisterValue): void {
    if (name.startsWith('global ')) {
      // Set the global register, clear all the local ones.
      name = name.slice(7);
      let i = this._parsingContexts.length - 1;
      while (i > 0) {
        if (this._parsingContexts[i].registers) {
          delete this._parsingContexts[i].registers![name];
        }
        i -= 1;
      }
      this._parsingContexts[0].registers![name] = value;
      return;
    }
    // Set the local register
    if (!this._parsingContexts[this._parsingContexts.length - 1].registers) {
      this._parsingContexts[this._parsingContexts.length - 1].registers = {};
    }
    this._parsingContexts[this._parsingContexts.length - 1].registers![name] =
      value;
  }

  /**
   * True if we've reached the end of the token stream
   */
  end(): boolean {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
  }

  get(): Token {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : '';
  }

  peek(): Token {
    return this.tokens[this.index];
  }

  /**
   * @return True if the next token matches the input, and advance
   */
  match(input: string): boolean {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * Return the last atom that can have a subscript/superscript attached to it.
   * If there isn't one, insert a `SubsupAtom` and return it.
   */
  lastSubsupAtom(): Atom {
    let atom: Atom;
    if (this.mathlist.length > 0) {
      atom = this.mathlist[this.mathlist.length - 1];

      // If this is a `subsup` atom, it can have a `subsup` attached to it.
      if (atom.type === 'msubsup') return atom;

      // if (atom.type === 'mop' && atom?.limits && atom?.limits !== undefined) {

      // An atom can have superscript/subscript attached to it if it accepts
      // limits (`\sum`, `\vec`...)
      if (atom.subsupPlacement !== undefined) return atom;
    }
    // Create a new `subsup` atom and return it
    atom = new SubsupAtom({ style: this.style });
    this.mathlist.push(atom);
    return atom;
  }

  /**
   * @return True if the next token matches the specified regular expression pattern.
   */
  hasPattern(pattern: RegExp): boolean {
    return pattern.test(this.tokens[this.index]);
  }

  hasInfixCommand(): boolean {
    const { index } = this;
    if (index < this.tokens.length && this.tokens[index].startsWith('\\')) {
      const info = getInfo(this.tokens[index], this.parseMode, this.macros);
      if (!info) return false;
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
        return false;
      }

      return info.infix ?? false;
    }

    return false;
  }

  matchColumnSeparator(): boolean {
    const { index } = this;
    if (this.tabularMode && this.tokens[index] === '&') {
      this.index++;
      return true;
    }

    return false;
  }

  matchRowSeparator(): boolean {
    const { index } = this;
    if (
      this.tabularMode &&
      (this.tokens[index] === '\\\\' || this.tokens[index] === '\\cr')
    ) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * Return the appropriate value for a placeholder, either a default
   * one, or if a value was provided for #? via args, that value.
   */
  placeholder(): Atom[] {
    const placeHolderArg = this.args?.('?');
    if (!placeHolderArg) {
      return [
        new PlaceholderAtom({
          mode: this.parseMode,
          style: this.style,
        }),
      ];
    }

    // If there is a specific value defined for the placeholder,
    // use it.
    return parseLatex(placeHolderArg, {
      parseMode: this.parseMode,
      onError: this.onError,
      registers: this.currentContext.registers,
      mathstyle: 'textstyle',
      colorMap: this.colorMap,
      backgroundColorMap: this.backgroundColorMap,
    });
  }

  matchWhitespace(): boolean {
    let found = false;
    while (this.match('<space>')) {
      found = true;
    }

    return found;
  }

  skipUntilToken(input: string): void {
    let token = this.tokens[this.index];
    while (token && token !== input) {
      token = this.tokens[++this.index];
    }

    if (token === input) {
      this.index++;
    }
  }

  skipFiller(): void {
    let done = false;
    do {
      const skippedSpace = this.matchWhitespace();
      const skippedRelax = this.match('\\relax');
      done = !skippedSpace && !skippedRelax;
    } while (!done);
  }

  /**
   * Keywords are used to specify dimensions, and for various other
   * syntactic constructs.
   *
   * Unlike commands, they are not case sensitive.
   *
   * There are 25 keywords:
   *
   * at by bp cc cm dd depth em ex fil fill filll height in minus
   * mm mu pc plus pt sp spread to true width
   *
   * TeX: 8212
   * @return true if the expected keyword is present
   */
  matchKeyword(keyword: string): boolean {
    const savedIndex = this.index;
    let done = this.end();
    let value = '';
    while (!done) {
      const token = this.get();
      if (isLiteral(token)) {
        value += token;
        done = this.end() || value.length >= keyword.length;
      } else {
        done = true;
      }
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) {
      this.index = savedIndex;
    }

    return hasKeyword;
  }

  /**
   * Return a sequence of characters as a string.
   * i.e. 'abcd' returns 'abcd'.
   * Terminates on the first non-literal token encountered
   * e.g. '<{>', '<}>' etc...
   * Will also terminate on character literal ']'
   */
  scanString(): string {
    let result = '';
    while (!this.end()) {
      if (this.match('<space>')) {
        result += ' ';
      } else {
        const token = this.peek();

        if (token === ']') break;

        if (isLiteral(token)) {
          result += this.get();
        } else if (token.startsWith('\\')) {
          // TeX will give a 'Missing \endcsname inserted' error
          // if it encounters any command when expecting a string.
          // We're a bit more lax.
          this.onError({ code: 'unbalanced-braces' });
          result += this.get();
        } else {
          // It's '<{>', '<}>', '<$>' or '<$$>
          break;
        }
      }
    }

    return result;
  }

  /**
   * Return a sequence of characters as a string.
   * Terminates on a balanced closing bracket
   * This is used by the `\ce` command
   */
  scanBalancedString(): string {
    let result = '';
    let done = this.end();
    let level = 1;
    while (!done) {
      if (this.match('<space>')) {
        result += ' ';
      } else {
        const token = this.get();
        if (token === '<{>') {
          result += '{';
          level += 1;
        } else if (token === '<}>') {
          level -= 1;
          if (level > 0) {
            result += '}';
          } else {
            this.index -= 1;
          }
        } else if (token === '<$>') {
          result += '$';
        } else if (token === '<$$>') {
          result += '$$';
        } else {
          result += token;
        }
      }

      done = level === 0 || this.end();
    }

    return result;
  }

  /**
   * Return the literal tokens, as a string, until a matching closing "}"
   */
  matchLiteralArg(): string {
    let result = '';
    if (this.match('<{>')) {
      let depth = 1;
      while (depth > 0 && !this.end()) {
        const token = this.get()!;
        if (token === '<}>') {
          depth -= 1;
          if (depth > 0) {
            // Don't include final '}'
            result += '}';
          }
        } else if (token === '<{>') {
          depth += 1;
          result += '{';
        } else {
          result +=
            {
              '<space>': ' ',
              '<$$>': '$$',
              '<$>': '$',
            }[token] ?? token;
        }
      }
    }

    return result;
  }

  /**
   * Return as a number a group of characters representing a
   * numerical quantity.
   *
   * From TeX:8695 (scan_int):
   * > An integer number can be preceded by any number of spaces and `+' or
   * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
   * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
   * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
   * > an internal variable.
   */
  scanNumber(isInteger = true): null | number {
    let negative = false;
    let token = this.peek();
    while (token === '<space>' || token === '+' || token === '-') {
      this.get();
      if (token === '-') negative = !negative;
      token = this.peek();
    }

    isInteger = Boolean(isInteger);

    let radix = 10;
    let digits = /\d/;
    if (this.match("'")) {
      // Apostrophe indicates an octal value
      radix = 8;
      digits = /[0-7]/;
      isInteger = true;
    } else if (this.match('"') || this.match('x')) {
      // Double-quote indicates a hex value
      // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
      // For example: 'x3a'
      radix = 16;
      // Hex digits have to be upper-case
      digits = /[\dA-F]/;
      isInteger = true;
    } else if (this.match('`')) {
      // A backtick indicates an alphabetic constant: a letter, or a single-letter command
      token = this.get();
      if (token) {
        if (token.startsWith('\\') && token.length === 2) {
          return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);
        }

        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }

      return null;
    }

    let value = '';
    while (this.hasPattern(digits)) {
      value += this.get();
    }

    // Parse the fractional part, if applicable
    if (!isInteger && (this.match('.') || this.match(','))) {
      value += '.';
      while (this.hasPattern(digits)) {
        value += this.get();
      }
    }

    const result: number = isInteger
      ? Number.parseInt(value, radix)
      : Number.parseFloat(value);
    if (Number.isNaN(result)) return null;
    return negative ? -result : result;
  }

  /**
   * Return a dimension
   *
   * See TeX:8831
   */
  scanDimen(): Dimension | null {
    let value = this.scanNumber(false);
    if (value === null) {
      // This wasn't a number, but perhaps it's a register name?
      if (this.peek()?.startsWith('\\')) {
        value = 1;
      } else {
        return null;
      }
    }
    this.matchWhitespace();
    let result: Dimension;
    if (this.matchKeyword('pt')) {
      result = { dimension: value, unit: 'pt' };
    } else if (this.matchKeyword('mm')) {
      result = { dimension: value, unit: 'mm' };
    } else if (this.matchKeyword('cm')) {
      result = { dimension: value, unit: 'cm' };
    } else if (this.matchKeyword('ex')) {
      result = { dimension: value, unit: 'ex' };
    } else if (this.matchKeyword('px')) {
      result = { dimension: value, unit: 'px' };
    } else if (this.matchKeyword('em')) {
      result = { dimension: value, unit: 'em' };
    } else if (this.matchKeyword('bp')) {
      result = { dimension: value, unit: 'bp' };
    } else if (this.matchKeyword('dd')) {
      result = { dimension: value, unit: 'dd' };
    } else if (this.matchKeyword('pc')) {
      result = { dimension: value, unit: 'pc' };
    } else if (this.matchKeyword('in')) {
      result = { dimension: value, unit: 'in' };
    } else if (this.matchKeyword('mu')) {
      result = { dimension: value, unit: 'mu' };
    } else {
      if (this.peek()?.startsWith('\\')) {
        result = convertToDimension(
          this.getRegister(this.get().slice(1)),
          this.currentContext.registers
        ) ?? { dimension: 0 };
        result.dimension *= value;
      } else {
        if (!this.match('\\relax')) {
          // If the units are missing, TeX assumes 'pt'
          this.onError({ code: 'missing-unit' });
        }
        result = { dimension: value, unit: 'pt' };
      }
    }

    return result;
  }

  scanGlue(): Glue | null {
    const dimen = this.scanDimen();
    if (dimen === null) return null;
    const result: Glue = { glue: dimen };
    // We parse, but ignore, the optional 'plus' and 'minus'
    // arguments.

    this.matchWhitespace();
    if (this.match('\\relax')) return result;

    // 'plus', optionally followed by 'minus'
    // ('minus' cannot come before 'plus')
    // dimen or 'hfill'
    if (this.matchKeyword('plus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    this.matchWhitespace();
    if (this.match('\\relax')) return result;

    this.matchWhitespace();
    if (this.matchKeyword('minus')) {
      // @todo there could also be a \hFilLlL command here
      this.scanDimen();
    }

    return result;
  }

  scanColspec(): ColumnFormat[] | null {
    this.matchWhitespace();
    const result: ColumnFormat[] = [];
    while (!this.end() && !(this.peek() === '<}>' || this.peek() === ']')) {
      const literal = this.get();
      if (literal === 'c' || literal === 'r' || literal === 'l') {
        result.push({ align: literal });
      } else if (literal === '|') {
        result.push({ separator: 'solid' });
      } else if (literal === ':') {
        result.push({ separator: 'dashed' });
      } else if (literal === '@') {
        if (this.match('<{>')) {
          this.beginContext({ mode: 'math' });
          result.push({
            gap: this.parse((token) => token === '<}>'),
          });
          this.endContext();
        }

        if (!this.match('<}>')) {
          this.onError({ code: 'unbalanced-braces' });
        }
      }
    }

    return result;
  }

  /**
   * Parse a `\(...\)` or `\[...\]` sequence
   * @return group for the sequence or null
   */
  parseModeSet(): Atom | null {
    let final: Token = '';
    if (this.match('\\(')) final = '\\)';
    if (!final && this.match('\\[')) final = '\\]';
    if (!final) return null;
    this.beginContext({
      mode: 'math',
      mathstyle: final === '\\)' ? 'textstyle' : 'displaystyle',
    });

    const result = new GroupAtom(
      this.parse((token) => token === final),
      {
        mathstyleName: final === '\\)' ? 'textstyle' : 'displaystyle',
        latexOpen: final === '\\]' ? '\\[' : '\\(',
        latexClose: final,
        boxType: 'mord',
      }
    );
    if (!this.match(final)) {
      this.onError({ code: 'unbalanced-mode-shift' });
    }

    this.endContext();
    if (result.hasEmptyBranch('body')) return null;

    return result;
  }

  /**
   * Parse a `$...$` or `$$...$$` sequence
   */
  parseModeShift(): Atom | null {
    let final: Token = '';
    if (this.match('<$>')) final = '<$>';
    if (!final && this.match('<$$>')) final = '<$$>';
    if (!final) return null;

    this.beginContext({
      mode: 'math',
      mathstyle: '<$>' ? 'textstyle' : 'displaystyle',
    });

    const result = new GroupAtom(
      this.parse((token: Token) => token === final),
      {
        mathstyleName: final === '<$>' ? 'textstyle' : 'displaystyle',
        latexOpen: final === '<$>' ? '$ ' : '$$ ',
        latexClose: final === '<$>' ? ' $' : ' $$',
      }
    );
    if (!this.match(final)) {
      this.onError({ code: 'unbalanced-mode-shift' });
    }

    this.endContext();
    if (result.hasEmptyBranch('body')) return null;
    return result;
  }

  /**
   * Parse a \begin{env}...\end{end} sequence
   */
  parseEnvironment(): Atom | null {
    // An environment starts with a \begin command
    if (!this.match('\\begin')) return null;

    // The \begin command is immediately followed by the environment
    // name, as a string argument
    const envName = this.parseArgument('string');
    if (!envName) return null;
    const def = getEnvironmentDefinition(envName);
    if (!def) {
      this.onError({
        code: 'unknown-environment',
        arg: envName,
      });
      return null;
    }

    // If the environment has some arguments, parse them
    const args: (null | Argument)[] = [];
    if (def.params) {
      for (const parameter of def.params) {
        // Parse an argument
        if (parameter.isOptional) {
          // If it's not present, parseOptionalArgument returns null,
          // but push it on the list of arguments anyway.
          // The null value will be interpreted as unspecified
          // optional value by the command parse function.
          args.push(this.parseOptionalArgument(parameter.type));
        } else {
          const arg: Argument | null = this.parseArgument(parameter.type);
          if (!arg) {
            this.onError({
              code: 'missing-argument',
              arg: envName,
            });
          }

          args.push(arg);
        }
      }
    }

    this.beginContext({ tabular: def.tabular });

    const array: Atom[][][] = [];
    const rowGaps: Dimension[] = [];
    let row: Atom[][] = [];
    let done = false;
    do {
      if (this.end()) {
        this.onError({ code: 'unbalanced-environment', arg: envName });
        done = true;
      }

      if (!done && this.match('\\end')) {
        if (this.parseArgument('string') !== envName) {
          this.onError({
            code: 'unbalanced-environment',
            arg: envName,
          });
        }

        done = true;
      }

      if (!done) {
        if (this.matchColumnSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
        } else if (this.matchRowSeparator()) {
          row.push(this.mathlist);
          this.mathlist = [];
          let gap: Dimension | null = null;
          this.matchWhitespace();
          if (this.match('[')) {
            gap = this.scanDimen();
            this.matchWhitespace();
            this.match(']');
          }

          rowGaps.push(gap ?? { dimension: 0 });
          array.push(row);
          row = [];
        } else {
          this.mathlist = this.mathlist.concat(
            this.parse(
              (token: Token) =>
                token === '<}>' ||
                token === '&' ||
                token === '\\end' ||
                token === '\\cr' ||
                token === '\\\\'
            )
          );
        }
      }
    } while (!done);

    row.push(this.mathlist);
    if (row.length > 0) array.push(row);

    this.endContext();

    return def.createAtom(envName, array, rowGaps, args);
  }

  /**
   * Parse a sequence until a group end marker, such as
   * `}`, `\end`, `&`, etc...
   *
   * Returns an array of atoms or an empty array if the sequence
   * terminates right away.
   *
   * @param done - A predicate indicating if a
   * token signals the end of an implicit group
   */
  parse(done?: (token: Token) => boolean): Atom[] {
    this.beginContext();
    if (!done) {
      // Default group end marker
      done = (token: Token): boolean => token === '<}>';
    }

    // To handle infix commands, we'll keep track of their prefix
    // (tokens coming before them) and their arguments
    let infix: Token = '';
    let infixInfo: FunctionDefinition | null = null;
    let infixArgs: Atom[][] = [];
    let prefix: Atom[] | null = null;
    const saveAtoms = this.mathlist;
    this.mathlist = [];
    while (!this.end() && !done(this.peek())) {
      if (this.hasInfixCommand() && !infix) {
        // The next token is an infix and we have not seen one yet
        // (there can be only one infix command per implicit group).
        infix = this.get();
        // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode
        infixInfo = getInfo(infix, 'math', this.macros) as FunctionDefinition;
        if (infixInfo) {
          infixArgs = this.parseArguments(infixInfo)[1] as Atom[][];
        }

        // Save the math list so far and start a new one
        prefix = this.mathlist;
        this.mathlist = [];
      } else {
        this.parseToken();
      }
    }

    let result: Atom[];
    if (infix) {
      console.assert(Boolean(infixInfo));
      infixArgs.unshift(this.mathlist); // Suffix
      this.mathlist = saveAtoms;
      if (prefix) infixArgs.unshift(prefix);
      result = [
        infixInfo!.createAtom!(infix, infixArgs, this.style, {
          colorMap: this.colorMap,
          backgroundColorMap: this.backgroundColorMap,
        }),
      ];
    } else {
      result = this.mathlist;
      this.mathlist = saveAtoms;
    }

    this.endContext();

    return result;
  }

  /**
   * Parse a group enclosed in a pair of braces: `{...}`.
   *
   * Return either a group Atom or null if not a group.
   *
   * Return a group Atom with an empty body if an empty
   * group (i.e. `{}`).
   */
  parseGroup(): Atom | null {
    if (!this.match('<{>')) return null;
    const result = new GroupAtom(
      this.parse((token: Token) => token === '<}>'),
      {
        mode: this.parseMode,
        latexOpen: '{',
        latexClose: '}',
      }
    );
    if (!this.match('<}>')) {
      this.onError({ code: 'unbalanced-braces' });
    }
    return result;
  }

  scanSmartFence(): Atom | null {
    this.matchWhitespace();
    if (!this.match('(')) return null;
    // We've found an open paren... Convert to a `\mleft...\mright`
    this.beginContext();
    let nestLevel = 1;
    while (!this.end() && nestLevel !== 0) {
      if (this.match('(')) nestLevel += 1;
      if (this.match(')')) nestLevel -= 1;
      if (nestLevel !== 0) this.parseToken();
    }

    if (nestLevel === 0) this.match(')');
    const result = new LeftRightAtom(this.mathlist, {
      inner: false,
      leftDelim: '(',
      rightDelim: nestLevel === 0 ? ')' : '?',
    });

    this.endContext();
    return result;
  }

  /**
   * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
   *
   * @return The delimiter (as a character or command) or null
   */
  scanDelim(): string | null {
    this.matchWhitespace();
    const token = this.get();
    if (!token) {
      this.onError({ code: 'unexpected-end-of-string' });
      return null;
    }

    let delim = '.';
    if (token.startsWith('\\') || isLiteral(token)) {
      delim = token;
    }

    const info = getInfo(delim, 'math', this.macros);
    if (!info) {
      this.onError({ code: 'unknown-command', arg: delim });
      return null;
    }

    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      this.onError({ code: 'unexpected-delimiter', arg: delim });
      return null;
    }

    if (info.type === 'mopen' || info.type === 'mclose') {
      return delim;
    }

    // Some symbols are not of type mopen/mclose, but are still
    // valid delimiters...
    // '?' is a special delimiter used as a 'placeholder'
    // (when the closing delimiter is displayed greyed out)
    if (
      /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
        delim
      )
    ) {
      return delim;
    }

    this.onError({ code: 'unexpected-delimiter', arg: delim });
    return null;
  }

  /**
   * Parse a `/left.../right` sequence.
   *
   * Note: the `/middle` command can occur multiple times inside a
   * `/left.../right` sequence, and is handled separately.
   *
   * Return either an atom of type `'leftright'` or null
   */
  parseLeftRight(): Atom | null {
    if (this.match('\\right') || this.match('\\mright')) {
      // We have an unbalanced left/right (there's a \right, but no \left)
      this.onError({ code: 'unbalanced-braces' });
      return null;
    }

    let close = '\\right';
    if (!this.match('\\left')) {
      if (!this.match('\\mleft')) return null;
      close = '\\mright';
    }

    const leftDelim = this.scanDelim();
    if (!leftDelim) return null;

    this.beginContext();

    while (!this.end() && !this.match(close)) {
      this.parseToken();
    }

    const body = this.mathlist;
    this.endContext();

    // If we've reached the end and there was no `\right` or
    // there isn't a valid delimiter after `\right`, we'll
    // consider the `\right` missing and set the `rightDelim` to undefined
    const rightDelim = this.scanDelim() ?? '.';

    return new LeftRightAtom(body, {
      leftDelim,
      rightDelim,
      inner: close === '\\right',
      style: this.style,
    });
  }

  /**
   * Parse a subscript/superscript: `^` and `_`.
   *
   * Modify the last atom accordingly, or create a new 'msubsup' carrier.
   *
   */
  parseSupSub(): boolean {
    // No sup/sub in text or command mode.
    if (this.parseMode !== 'math') return false;

    // Apply the subscript/superscript to the last rendered atom.
    // If none is present (beginning of the list, i.e. `{^2}`,
    // an empty atom will be created, equivalent to `{{}^2}`
    let token = this.peek();
    if (token !== '^' && token !== '_' && token !== "'") return false;

    while (token === '^' || token === '_' || token === "'") {
      if (this.match("'")) {
        if (this.match("'")) {
          // A single quote, twice, is equivalent to '^{\doubleprime}'
          this.lastSubsupAtom().addChild(
            new Atom('mord', {
              command: '\\doubleprime',
              mode: 'math',
              value: '\u2032\u2032', // "\u2033" displays too high
            }),
            'superscript'
          );
        } else {
          // A single quote (prime) is equivalent to '^{\prime}'
          this.lastSubsupAtom().addChild(
            new Atom('mord', {
              command: '\\prime',
              mode: 'math',
              value: '\u2032',
            }),
            'superscript'
          );
        }
      } else if (this.match('^') || this.match('_')) {
        const arg = this.parseArgument('math');
        if (arg) {
          this.lastSubsupAtom().addChildren(
            arg,
            token === '_' ? 'subscript' : 'superscript'
          );
        } else {
          this.lastSubsupAtom().createBranch(
            token === '_' ? 'subscript' : 'superscript'
          );
        }
      }

      token = this.peek();
    }

    return true;
  }

  /**
   * Parse a `\limits` or `\nolimits` command.
   *
   * This will change the placement of limits to be either above or below
   * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
   *
   * This overrides the calculation made for the placement, which is usually
   * dependent on the displaystyle (`textstyle` prefers `\nolimits`, while
   * `displaystyle` prefers `\limits`).
   */
  parseLimits(): boolean {
    // Note: `\limits`, `\nolimits` and `\displaylimits` are only applicable \
    // after an operator.
    // We skip them and ignore them if they are after something other
    // than an operator (TeX throws an error)

    const isLimits = this.match('\\limits');
    const isNoLimits = !isLimits && this.match('\\nolimits');
    const isDisplayLimits =
      !isNoLimits && !isLimits && this.match('\\displaylimits');

    if (!isLimits && !isNoLimits && !isDisplayLimits) return false;

    const opAtom =
      this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;

    if (opAtom === null || opAtom.type !== 'mop') return false;

    if (isLimits) {
      opAtom.subsupPlacement = 'over-under';
      // Record that the limits was set through an explicit command
      // so we can generate the appropriate LaTeX later
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    if (isNoLimits) {
      opAtom.subsupPlacement = 'adjacent';
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    if (isDisplayLimits) {
      opAtom.subsupPlacement = 'auto';
      opAtom.explicitSubsupPlacement = true;
      return true;
    }

    return false;
  }

  parseArguments(
    info: Partial<FunctionDefinition>
  ): [ParseMode | undefined, (null | Argument)[]] {
    if (!info || !info.params) return [undefined, []];
    let explicitGroup: ParseMode | undefined = undefined;
    const args: (null | Argument)[] = [];
    let i = info.infix ? 2 : 0;
    while (i < info.params.length) {
      const parameter = info.params[i];
      // Parse an argument
      if (parameter.type === 'rest') {
        args.push(
          this.parse(
            (token: Token) =>
              token === '<}>' ||
              token === '&' ||
              token === '\\end' ||
              token === '\\cr' ||
              token === '\\\\'
          )
        );
      } else if (parameter.isOptional) {
        args.push(this.parseOptionalArgument(parameter.type));
      } else if (parameter.type.endsWith('*')) {
        // For example 'math*'.
        // In this case, indicate that a 'yet-to-be-parsed'
        // argument (and 'explicit group') is present
        explicitGroup = parameter.type.slice(0, -1) as ParseMode;
      } else {
        const arg = this.parseArgument(parameter.type);
        if (arg !== null) {
          args.push(arg);
        } else {
          // Report an error
          this.onError({ code: 'missing-argument' });
          switch (parameter.type) {
            case 'number':
              // case 'dimen':
              // case 'glue':
              args.push(0);
              break;
            case 'dimen':
              args.push({ dimension: 0, unit: 'pt' });
              break;
            case 'glue':
              args.push({ glue: { dimension: 0, unit: 'pt' } });
              break;
            case 'string':
            case 'balanced-string':
              args.push('');
              break;
            case 'delim':
              args.push('.');
              break;
            case 'colspec':
              args.push('llllllllll');
              break;
            case 'auto':
            default:
              args.push(this.placeholder());
              break;
          }
        }
      }

      i += 1;
    }

    return [explicitGroup, args];
  }

  /**
   * Parse a math field (in the TeX parlance), an argument to a function.
   *
   * An argument can either be a single atom or  a sequence of atoms enclosed
   * in braces.
   *
   */
  parseArgument(argType: 'auto'): null | Atom[];
  parseArgument(argType: ParseMode): null | Atom[];
  parseArgument(argType: 'balanced-string'): null | string;
  parseArgument(argType: 'colspec'): null | ColumnFormat[];
  parseArgument(argType: 'delim'): null | string;
  parseArgument(argType: 'dimen'): null | number;
  parseArgument(argType: 'number'): null | number;
  parseArgument(argType: 'glue'): null | number;
  parseArgument(argType: 'string'): null | string;
  parseArgument(argType: ArgumentType): null | Argument;
  parseArgument(argType: ArgumentType): null | Argument {
    this.skipFiller();
    argType = argType === 'auto' ? this.parseMode : argType;
    let result: Argument | null = null;
    // An argument (which is called a 'math field' in TeX)
    // could be a single character or symbol, as in `\frac12`
    // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
    // ``\frac{\sqrt}{-1}{\beta}``
    if (!this.match('<{>')) {
      if (argType === 'delim') {
        return this.scanDelim() ?? '.';
      }

      if (argType === 'text' || argType === 'math') {
        // Parse a single token.
        this.beginContext();
        const atom = this.parseSimpleToken();
        this.endContext();
        return atom;
      }
    }

    if (argType === 'text' || argType === 'math') {
      this.beginContext({ mode: argType });

      // Collect an array of tokens until a balanced "}"
      const initialIndex = this.index;
      let depth = 1;
      do {
        const token = this.get();
        if (token === '<}>') depth -= 1;
        if (token === '<{>') depth += 1;
      } while (depth > 0 && !this.end());

      result = Mode.parseTokens(
        argType,
        this.tokens.slice(initialIndex, this.index - 1),
        this.onError,
        {
          args: this.args ?? (() => ''),
          macros: this.macros ?? {},
          smartFence: this.smartFence,
          style: this.style,
          parse: (
            mode: ParseMode,
            tokens: Token[],
            options
          ): [Atom[], Token[]] => {
            const parser = new Parser(tokens, {
              args: options.args,
              parseMode: mode,
              smartFence: this.smartFence,
              macros: options.macros,
              registers: this.currentContext.registers,
              mathstyle: this.currentContext.mathstyle,
              colorMap: this.colorMap,
              backgroundColorMap: this.backgroundColorMap,
              style: options.style,
              onError: this.onError,
            });
            result = parser.parse();
            return [result, tokens.slice(parser.index)];
          },
        }
      );

      if (!result) {
        // No mode-specific result. Try again from the start
        this.index = initialIndex;
        do {
          this.mathlist = this.mathlist.concat(this.parse());
        } while (!this.match('<}>') && !this.end());
      }
    } else {
      this.beginContext();
      if (argType === 'string') {
        result = this.scanString();
      } else if (argType === 'balanced-string') {
        result = this.scanBalancedString();
      } else if (argType === 'number') {
        result = this.scanNumber();
      } else if (argType === 'colspec') {
        result = this.scanColspec();
      } else if (argType === 'dimen') {
        result = this.scanDimen();
      } else if (argType === 'glue') {
        result = this.scanGlue();
      } else if (argType === 'delim') {
        result = this.scanDelim() ?? '.';
      }
      if (result === null) {
        this.endContext();
        return null;
      }

      this.skipUntilToken('<}>');
    }

    const atoms = this.mathlist;
    this.endContext();
    return result ?? atoms;
  }

  parseOptionalArgument(argType: ArgumentType): Argument | null {
    argType = argType === 'auto' ? this.parseMode : argType;
    this.matchWhitespace();
    if (!this.match('[')) return null;
    let result: Argument | null = null;
    while (!this.end() && !this.match(']')) {
      if (argType === 'string') {
        result = this.scanString();
      } else if (argType === 'number') {
        result = this.scanNumber();
      } else if (argType === 'dimen') {
        result = this.scanDimen();
      } else if (argType === 'glue') {
        result = this.scanGlue();
      } else if (argType === 'colspec') {
        result = this.scanColspec();
      } else if (argType === 'bbox') {
        // The \bbox command takes a very particular argument:
        // a comma delimited list of up to three arguments:
        // a color, a dimension and a string.
        // Split the string by comma delimited sub-strings, ignoring commas
        // that may be inside (). For example"x, rgb(a, b, c)" would return
        // ['x', 'rgb(a, b, c)']
        const list = this.scanString()
          .toLowerCase()
          .trim()
          .split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
        const bboxParameter: BBoxParameter = {};
        for (const element of list) {
          const color = this.backgroundColorMap?.(element);
          if (color) {
            bboxParameter.backgroundcolor = color;
          } else {
            const m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
            if (m) {
              bboxParameter.padding = m[0];
            } else {
              const m = element.match(/^\s*border\s*:\s*(.*)/);
              if (m) {
                bboxParameter.border = m[1];
              }
            }
          }
        }

        result = bboxParameter;
      } else if (argType === 'math') {
        this.beginContext({ mode: 'math' });
        result = this.mathlist.concat(this.parse((token) => token === ']'));
        this.endContext();
      }
    }

    return result;
  }

  parseCommand(command: string): Atom[] | null {
    let result: Atom | null = null;
    if (command === '\\placeholder') {
      const placeholder = new PlaceholderAtom({
        mode: this.parseMode,
        placeholderId: this.parseOptionalArgument('string') as string,
        default: this.parseOptionalArgument('math') as Atom[],
        value: this.parseArgument('string') ?? undefined,
        style: this.style,
      });
      return [placeholder];
    }

    if (command === '\\char') {
      // \char has a special syntax and requires a non-braced integer
      // argument
      const initialIndex = this.index;
      let codepoint = Math.floor(this.scanNumber(true) ?? Number.NaN);
      if (
        !Number.isFinite(codepoint) ||
        codepoint < 0 ||
        codepoint > 0x10ffff
      ) {
        codepoint = 0x2753; // BLACK QUESTION MARK
      }

      const verbatimLatex =
        '\\char' + tokensToString(this.tokens.slice(initialIndex, this.index));
      result = new Atom(this.parseMode === 'math' ? 'mord' : 'text', {
        command: '\\char',
        mode: this.parseMode,
        value: String.fromCodePoint(codepoint),
        serialize: () => verbatimLatex,
      });
      result.verbatimLatex = verbatimLatex;

      return [result];
    }

    if (command === '\\hskip' || command === '\\kern') {
      // \hskip and \kern have a special syntax and requires a non-braced
      // 'skip' argument
      const width = this.scanGlue();
      if (!width) return null;
      return [new SpacingAtom(command, this.style, width)];
    }

    // Is this a macro?
    result = this.scanMacro(command);
    if (result) return [result];

    // This wasn't a macro, so let's see if it's a regular command
    const info = getInfo(command, this.parseMode, {});

    if (!info) {
      // An unknown command
      this.onError({
        code: 'unknown-command',
        arg: command,
      });
      return [new ErrorAtom(command)];
    }

    if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
      // Command not applicable in this mode: ignore it (TeX behavior)
      // (for example `\Huge` in math mode
      return [];
    }

    // Parse the arguments.
    //
    // If `deferredArg` is not empty, the content after the command
    // will be parsed *after* the command has been initially processed
    // (atom creation or style application) and passed to
    //
    // This is used for commands such as \textcolor{color}{content}
    // that need to apply the color to the content *after* the
    // style has been changed.
    //
    // In definitions, this is indicated with a parameter type
    // thats ends with a '*' ('math*', 'auto*').

    const savedMode = this.parseMode;
    if (info.applyMode) {
      this.parseMode = info.applyMode;
    }

    const initialIndex = this.index;
    const [deferredArg, args] = this.parseArguments(info);
    this.parseMode = savedMode;

    if (!args) return null; // Some required arguments were missing...

    if (info.applyMode && !info.applyStyle && !info.createAtom) {
      return args[0] as Atom[];
    }

    if (info.infix) {
      // Infix commands should be handled in scanImplicitGroup
      // If we find an infix command here, it's a syntax error
      // (second infix command in a group) and should be ignored.
      this.onError({
        code: 'too-many-infix-commands',
        arg: command,
      });
      return null;
    }

    //  Invoke the createAtom() function if present
    if (typeof info.createAtom === 'function') {
      result = info.createAtom(command, args, this.style, {
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap,
      });
      if (deferredArg) {
        result!.body = this.parseArgument(deferredArg) ?? undefined;
      }
    } else if (typeof info.applyStyle === 'function') {
      const style = info.applyStyle(command, args, {
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap,
      });
      // No type provided -> the parse function will modify
      // the current style rather than create a new Atom.
      const savedMode = this.parseMode;
      if (info.applyMode) {
        // Change to 'text' (or 'math') mode if necessary
        this.parseMode = info.applyMode;
      }

      // If a deferred arg is expected, process it now
      if (deferredArg) {
        // Create a temporary style
        const saveStyle = this.style;
        this.style = { ...this.style, ...style };
        const atoms = this.parseArgument(deferredArg);
        this.style = saveStyle;
        this.parseMode = savedMode;
        return atoms;
      }

      // Merge the new style info with the current style
      this.style = { ...this.style, ...style };
      this.parseMode = savedMode;
    } else {
      // The new atom will inherit the current style
      const style = { ...this.style };
      // Override the variant if an explicit variant is provided
      if (info.variant) {
        style.variant = info.variant;
      }
      result = new Atom(info.type ?? 'mop', {
        command,
        style,
        value: info.codepoint ? String.fromCodePoint(info.codepoint) : command,
        mode: info.applyMode ?? this.parseMode,
      });
    }

    if (
      result instanceof Atom &&
      !result.verbatimLatex &&
      !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)
    ) {
      result.verbatimLatex =
        (result.command ?? '') +
        tokensToString(this.tokens.slice(initialIndex, this.index));

      if (result.isFunction && this.smartFence) {
        // The command was a function that may be followed by
        // an argument, like `\sin(`
        const smartFence = this.scanSmartFence();
        if (smartFence) return [result, smartFence];
      }
    }

    if (!result) return null;
    return [result];
  }

  parseLiteral(literal: string): Atom[] | null {
    const result = Mode.createAtom(this.parseMode, literal, {
      ...this.style,
    });
    if (!result) return null;

    if (result.isFunction && this.smartFence) {
      // The atom was a function that may be followed by
      // an argument, like `f(`.
      const smartFence = this.scanSmartFence();
      if (smartFence) return [result, smartFence];
    }

    return [result];
  }

  parseSimpleToken(): Atom[] | null {
    const token = this.get();
    if (!token) return null;

    if (token === '<space>') {
      if (this.parseMode === 'text') {
        return [new TextAtom(' ', ' ', this.style)];
      }

      return null;
    }

    if (token.startsWith('\\')) return this.parseCommand(token);

    if (isLiteral(token)) return this.parseLiteral(token);

    if (token === '<}>') {
      this.onError({ latex: '', code: 'unbalanced-braces' });
    } else {
      this.onError({
        latex: '',
        code: 'unexpected-token',
        arg: token,
      });
    }

    return null;
  }

  /**
   * Attempt to scan the macro name and return an atom list if successful.
   * Otherwise, it wasn't a macro.
   */
  scanMacro(macro: string): Atom | null {
    const macroName = macro.slice(1);
    if (!this.macros || !this.macros[macroName]) return null;
    const initialIndex = this.index;
    const def = this.macros[macroName].def;
    const argCount = this.macros[macroName].args!;

    const args: Record<string, string | undefined> = {};
    for (let i = 1; i <= argCount; i++) {
      // Parse each argument as a string. We don't know yet
      // what the proper parse mode is, so defer parsing till later
      // when invoking `parseString`
      args[i] = this.matchLiteralArg();
    }

    // Carry forward the placeholder argument, if any.
    args['?'] = this.args?.('?');

    // Group the result of the macro expansion
    return new MacroAtom(macro, {
      expand: this.macros[macroName].expand,
      captureSelection: this.macros[macroName].captureSelection,
      args: tokensToString(this.tokens.slice(initialIndex, this.index)),
      body: parseLatex(def, {
        parseMode: this.parseMode,
        args: (arg: string): string => args[arg]!,
        macros: this.macros,
        registers: this.currentContext.registers ?? null,
        mathstyle: this.currentContext.mathstyle,
        colorMap: this.colorMap,
        backgroundColorMap: this.backgroundColorMap,
        onError: this.onError,
      }),
    });
  }

  /**
   * Make an atom for the current token or token group and
   * add it to the parser's mathlist
   */
  parseToken(): boolean {
    let result: null | Atom | Atom[] =
      this.parseEnvironment() ??
      this.parseModeShift() ??
      this.parseModeSet() ??
      this.parseGroup() ??
      this.parseLeftRight();
    if (result === null) {
      if (this.parseSupSub()) return true;
      if (this.parseLimits()) return true;
      result = this.parseSimpleToken();
    }
    // If we have an atom to add, push it at the end of the current math list
    // We could have no atom for tokens that were skipped, a ' ' in math mode
    // for example
    if (isArray<Atom>(result)) {
      this.mathlist = this.mathlist.concat(result);
    } else if (result) {
      this.mathlist.push(result);
    }

    return result !== null;
  }
}

/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 * @param smartFence - If true, promote plain fences, e.g. `(`,
 * as `\left...\right` or `\mleft...\mright`
 */
export function parseLatex(
  s: string,
  options?: {
    parseMode?: ParseMode;
    args?: null | ((arg: string) => string);
    macros?: null | MacroDictionary;
    registers?: Registers | null;
    mathstyle?: MathstyleName;
    smartFence?: boolean;
    onError?: ErrorListener<ParserErrorCode>;
    colorMap?: (name: string) => string | undefined;
    backgroundColorMap?: (name: string) => string | undefined;
  }
): Atom[] {
  const parser = new Parser(tokenize(s, options?.args ?? null), {
    args: options?.args ?? null,
    macros: getMacros(options?.macros),
    registers: options?.registers ?? null,
    mathstyle: options?.mathstyle ?? 'displaystyle',
    colorMap: options?.colorMap ?? defaultColorMap,
    parseMode: options?.parseMode ?? 'math',
    smartFence: options?.smartFence,
    backgroundColorMap:
      options?.backgroundColorMap ??
      options?.colorMap ??
      defaultBackgroundColorMap,
    onError: (err) => {
      if (typeof options?.onError === 'function') {
        options.onError({ ...err, latex: s });
      } else {
        // Console.warn(
        //     'MathLive parsing error: ' +
        //         err.code +
        //         (err.arg ? ' ' + err.arg + ' ' : ''),
        //     'in "' + s + '"'
        // );
      }
    },
  });

  let atoms: Atom[] = [];
  while (!parser.end()) {
    const more = parser.parse();
    if (!more) break;
    atoms = atoms.concat(more);
  }
  return atoms;
}

export function convertToGlue(
  value: RegisterValue,
  registers: Registers | null
): null | Glue {
  // If it's already a Glue, return it.
  if (typeof value === 'object' && 'glue' in value) return value;

  if (typeof value === 'object' && 'dimension' in value) {
    return { glue: value };
  }

  if (typeof value === 'number') return { glue: { dimension: value } };

  // It's a string, attempt to parse it.
  const parser = new Parser(tokenize(value), { registers });
  return parser.scanGlue();
}

/**  Return a dimension. */
export function convertToDimension(
  value: RegisterValue,
  registers: Registers | null
): null | Dimension {
  if (typeof value === 'number') return { dimension: value, unit: 'pt' };

  if (typeof value === 'object' && 'glue' in value) {
    value = value.glue;
  }

  if (typeof value === 'object' && 'dimension' in value) {
    return value;
  }

  // It's a string

  const parser = new Parser(tokenize(value), { registers });
  return parser.scanDimen();
}
